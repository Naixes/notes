# 概念
从⼴义上讲，数据结构就是指⼀组数据的存储结构。算法就是操作数据的⼀组⽅法。
从狭义上讲，是指某些著名的数据结构和算法，如队列、栈、堆、二分查找、动态规划等。
# 重点
-  复杂度分析
-  20个基础的数据结构与算法：
10个数据结构：数组、链表、栈、队列、散列表、⼆叉树、堆、跳表、图、Trie树；
10个算法：递归、排序、⼆分查找、搜索、哈希算法、贪⼼算法、分治算法、回溯算法、动态规划、字符串匹配算法。
# 复杂度分析
通过运行代码再进行监控和统计来评价算法的执行时间和内存占用的方法叫事后统计法，受测试环境和数据规模的影响较大，测试结果可能无法反映算法的性能
## 大O表示法
在不运行代码的情况下粗略的估计算法的执行效率
思路：将一行代码的执行时间假设为1个unit_time，计算算法的总执行时间。可以得出结论：代码的总执行时间 T(n) 和每行代码的执行次数 n 成正比，写成公式就是
`T(n) = O(f(n)) // f(n) `表示每行代码执行次数的总和

## 大O时间复杂度
实际上并不具体表示代码真正的执⾏时间，⽽是表示代码执⾏时间随数据规模增⻓的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
### 分析方法
1. 只关注执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

# 数据结构

## 数组

### 定义

**线性表**数据结构.用一组**连续的内存空间**存储一组**相同类型**的数据

- 线性表:数据排列成线一样的结构,每个数据最多有前后两个方向.比如:栈,链表,队列等

- 非线性表:数据之间不是简单的前后关系

- 连续的内存空间和型同类型的数据:有**随机访问的特性**,但也让很多操作变得低效,比如删除和插入

### 插入

有序:每个位置插入的时间复杂度是n

无序:只当作一个存储集合,可以插入到固定位置k,将k位置的元素放到最后,时间复杂度是1

### 删除

和插入类似

在一些特殊场景下,不一定追求连续性,将多次删除操作一起执行可以提高效率,比如只是记录数据已经被删除,在没有更多的空间时,一次性删除,也是JVM标记清除垃圾回收机制的核心思想

### 数组的访问越界

在C中是⼀种未决⾏为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问⼀段连续内存，只要数组通过偏移计算得到的内存地址是可⽤的，那么程序就可能不会报任何错误。

很多计算机病毒也正是利⽤到了代码中的数组越界可以访问⾮法地址的漏洞，来攻击系统，所以写代码的时候⼀定要警惕数组越界。

Java本身就会做越界检查，会抛出java.lang.ArrayIndexOutOfBoundsException。

### 容器

针对数组类型，很多语⾔都提供了容器类，⽐如Java中的ArrayList、C++ STL中的vector。

ArrayList最⼤的优势就是可以将很多数组操作的细节封装起来。⽐如前⾯提到的数组插⼊、删除数据时需要搬移其他数据等。另外，它还有⼀个优势，就是⽀持动态扩容。每次存储空间不够的时候，它都会将空间⾃动扩容为1.5倍⼤⼩。这⾥需要注意⼀点，因为扩容操作涉及内存申请和数据搬移，是⽐较耗时的。所以，最好在创建ArrayList的时候事先指定数据⼤⼩。

1.Java ArrayList⽆法存储基本类型，⽐如int、long，需要封装为Integer、Long类，⽽Autoboxing、Unboxing则有⼀定的性能消耗，所以如果特别关注性能，或者希望使⽤基本类型，就可以选⽤数组。

2.如果数据⼤⼩事先已知，并且对数据的操作⾮常简单，⽤不到ArrayList提供的⼤部分⽅法，也可以直接使⽤数组。

3.当要表示多维数组时，⽤数组往往会更加直观。⽐如Object[][] array；⽽⽤容器的话则需要这样定义：ArrayList<ArrayList > array。

**总结**：如果是做⼀些⾮常底层的开发，⽐如开发⽹络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为⾸选。

> 为什么⼤多数编程语⾔中，数组要从0开始编号，⽽不是从1开始呢？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前⾯也讲到，如果⽤a来表示数组的⾸地址，a[0]就是偏移为0的位置，也就是⾸地址

计算a[k]的内存地址只需要⽤这个公式：a[k]_address = base_address + (k-1)\*type_size

C语⾔设计者⽤0开始计数数组下标，之后的Java、JavaScript等⾼级语⾔都效仿了C语⾔，为了减少学习成本

## 链表

### LRU缓存淘汰算法

当缓存被⽤满时就需要缓存淘汰策略来决定。常⻅的有三种：先进先出策略FIFO（First In，First Out）、最少使⽤策略LFU（Least Frequently Used）、最近最少使⽤策略LRU（Least Recently Used）。

从底层的存储结构来看：它通过“指针”将⼀组零散的内存块串联起来使⽤，其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下⼀个结点的地址。这个记录下个结点地址的指针叫作后继指针next。

### 单链表

头结点⽤来记录链表的基地址。有了它，我们就可以遍历得到整条链表。

尾结点的指针不是指向下⼀个结点，⽽是指向⼀个空地址NULL，表示这是链表上最后⼀个结点。

**插入和删除**：

因为链表的存储空间本身就不是连续的。所以，在链表中插⼊和删除⼀个数据是⾮常快速的。对应的时间复杂度是O(1)。

随机访问：因为链表中的数据并⾮连续存储的，需要根据指针⼀个结点⼀个结点地依次遍历，直到找到相应的结点。

### 循环链表

⼀种特殊的单链表。它跟单链表唯⼀的区别就在尾结点。循环链表的尾结点指针是指向链表的头结点。它像⼀个环⼀样⾸尾相连，所以叫作“循环”链表。

循环链表的优点是从链尾到链头⽐较⽅便。当要处理的数据具有环型结构特点时，就特别适合采⽤循环链表。⽐如著名的约瑟夫问题。

### 双向链表

它⽀持两个⽅向，每个结点不⽌有⼀个后继指针next指向后⾯的结点，还有⼀个前驱指针prev指向前⾯的结点。

双向链表要⽐单链表占⽤更多的内存空间。虽然两个指针⽐较浪费存储空间，但可以⽀持双向遍历，这样也带来了双向链表操作的灵活性。

**插入和删除**：

删除结点中“值等于某个给定值”的结点：从头结点开始⼀个⼀个依次遍历对⽐，直到找到值等于给定值的结点，然后再指针操作将其删除。对应的时间复杂度为O(n)。

删除给定指针指向的结点：我们已经找到了要删除的结点，删除某个结点q需要知道其前驱结点，对于双向列表来说是已知的，所以时间复杂度为O(1)*

Java中的LinkedHashMap这个容器的实现原理，其中就⽤到了双向链表这种数据结构。

### 双向循环链表

### 数组和链表

两种截然不同的内存组织⽅式。正是因为内存存储的区别，它们插⼊、删除、随机访问操作的时间复杂度正好相反。

数组简单易⽤，在实现上使⽤的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以**访问效率更⾼**。

链表在内存中并不是连续存储，所以**对CPU缓存不友好，没办法有效预读**。

数组的缺点是**⼤⼩固定**，⼀经声明就要占⽤整块连续内存空间。如果声明的数组过⼤，可能导致“内存不⾜（out of memory）”。如果声明的数组过⼩，则可能出现不够⽤的情况。这时只能再申请⼀个更⼤的内存空间，把原数组拷⻉进去，⾮常费时。

链表本身没有⼤⼩的限制，天然地⽀持**动态扩容**，这也是它与数组最⼤的区别。

### 书写技巧

#### 理解引用或指针

有些语⾔有“指针”的概念，⽐如C语⾔；有些语⾔没有指针，取⽽代之的是“引⽤”，⽐如Java、Python。不管是“指针”还是“引⽤”，实际上，它们的意思都是⼀样的，都是存储所指对象的内存地址。

**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**

p->next=q：p结点中的next指针存储了q结点的内存地址。
p->next=p->next->next：p结点的next指针存储了p结点的下下⼀个结点的内存地址。

#### 警惕指针丢失和内存泄漏

我们希望在结点a和相邻的结点b之间插⼊结点x，假设当前指针p指向结点a。如果我们将代码实现变成下⾯这个样⼦，就会发⽣指针丢失和内存泄露。

```c
p->next = x; // 将p的next指针指向x结点；
x->next = p->next; // 相当于将x赋值给x->next，⾃⼰指向⾃⼰，整个链表也就断成了两半，从结点b往后的所有结点都⽆法访问到了。
```

对于有些语⾔来说，⽐如C语⾔，内存管理是由程序员负责的，如果没有⼿动释放结点对应的内存空间，就会产⽣内存泄露。所以，我们**插⼊结点时，⼀定要注意操作的顺序**，要先将结点x的next指针指向结点b，再把结点a的next指针指向结点x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插⼊代码，我们只需要把第1⾏和第2⾏代码的顺序颠倒⼀下就可以了。

#### 利用哨兵简化实现难度

针对链表的**插⼊、删除**操作，需要对插⼊第⼀个结点和删除**最后⼀个结点的情况进⾏特殊处理**。这样代码实现起来就会很繁琐，不简洁，⽽且也容易因为考虑不全⽽出错。哨兵，解决的是国家之间的边界问题。同理，这⾥说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。

在任何时候，不管链表是不是空，head指针都会⼀直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫作**不带头链表**。你可以发现，哨兵结点是**不存储数据**的。因为哨兵结点⼀直存在，所以插⼊第⼀个结点和插⼊其他结点，删除最后⼀个结点和删除其他结点，都可以统⼀为相同的代码实现逻辑了。

这种利⽤哨兵简化编程难度的技巧，在很多代码实现中都有⽤到，⽐如插⼊排序、归并排序、动态规划等。

#### 留意边界条件处理

- 如果链表为空时，代码是否能正常⼯作？
- 如果链表只包含⼀个结点时，代码是否能正常⼯作？
- 如果链表只包含两个结点时，代码是否能正常⼯作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常⼯作？

针对不同的场景，可能还有特定的边界条件，

#### 举例画图

#### 多写多练

5个常⻅的链表操作

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第n个结点
- 求链表的中间结点