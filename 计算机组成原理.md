冯诺依曼体系结构

计算机的基本硬件组成

**CPU**，CPU是一个超级精细的印刷电路版，它是计算机最重要的核心配件，叫中央处理器（Central	Processing	Unit），计算机的所有“计算”都是由CPU来进行的。

**内存**（Memory）。内存通常直接可以插在主板上，你撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行。程序读取的数据、计算得到的结果，也都要放在内存里。内存越大，能加载的东西自然也就越多。

存放在内存里的程序和数据，需要被CPU读取，CPU计算完之后，还要把数据写回到内存。然而CPU不能直接插到内存上，反之亦然。于是，就带来了最后一个大件——**主板**。

主板是一个有着各种各样，有时候多达数十乃至上百个插槽的配件。我们的CPU要插在主板上，内存也要插
在主板上。主板的芯片组（Chipset）和总线（Bus）解决了CPU和内存之间如何通信的问题。芯片组控制了
数据传输的流转，也就是数据从哪里到哪里的问题。总线则是实际数据传输的高速公路。因此，总线速度（Bus Speed）决定了数据能传输得多快。

有了三大件，只要配上电源供电，计算机差不多就可以跑起来了。但是现在还缺少各类输入（Input）/输出（Output）设备，也就是我们常说的**I/O设备**。

最后，你自己配的个人计算机，还要配上一个**硬盘**。这样各种数据才能持久地保存下来。绝大部分人都会给自己的机器装上一个机箱，配上风扇，解决灰尘和散热的问题。不过机箱和风扇，算不上是计算机的必备硬
件。

还有一个很特殊的设备，就是**显卡**（Graphics	Card）。现在，使用图形界面操作系统的计算机，无论是Windows、Mac	OS还是Linux，显卡都是必不可少的。装机的时候没有买显卡，计算机一样可以正常跑起来是因为，现在的主板都带了内置的显卡。如果你用计算机玩游戏，做图形渲染或者跑深度学习应用，你多半就需要买一张单独的显卡，插在主板上。显卡之所以特殊，是因为显卡里有除了CPU之外的另一个“处理器”，也就是GPU（Graphics	Processing	Unit，图形处理器），GPU一样可以做各种“计算”的工作。

鼠标、键盘以及硬盘，这些都是插在主板上的。作为外部I/O设备，它们是通过主板上的南桥
（SouthBridge）芯片组，来控制和CPU之间的通信的。“南桥”芯片的名字很直观，一方面，它在通常在主板的“南面”。另一方面，它的作用就是连接鼠标、键盘以及硬盘这些外部设备和CPU之间的通信。有了南桥，自然对应着也有“北桥”。是的，以前的主板上通常也有“北桥”芯片，用来作为“桥”，连接CPU和内存、显卡之间的通信。不过，随着时间的变迁，现在的主板上的“北桥”芯片的工作，已经被移到了CPU的内部，所以你在主板上，已经看不到北桥芯片了。

冯诺依曼体系结构

冯·诺依曼体系结构（Von Neumannarchitecture），也叫存储程序计算机。这里面其实暗含了两个概念，一个是“可编程”计算机，一个是“存储”计算机。

计算机是由各种门电路组合而成的，然后通过组装出一个固定的电路版，来完成一个特定的计算程序。一旦需要修改功能，就要重新组装电路。这样的话，计算机就是“不可编程”的，因为程序在计算机硬件层面是“写死”的。最常见的就是老式计算器，电路板设好了加减乘除，做不了任何计算逻辑固定之外的事情。

“存储”计算机。这其实是说，程序本身是存储在计算机的内存里，可以通过加载不同的程序来解决不同的问题。有“存储程序计算机”，自然也有不能存储程序的计算机。典型的就是早年的“Plugboard”这样的插线板式的计算机。整个计算机就是一个巨大的插线板，通过在板子上不同的插头或者接口的位置插入线路，来实现不同的功能。这样的计算机自然是“可编程”的，但是编写好的程序不能存储下来供下一次加载使用，不得不每次要用到和当前不同的“程序”的时候，重新插板子，重新“编程”。

冯祖师爷在First Draft里面说了一台计算机应该有哪些部分组成。首先是一个包含算术逻辑单元（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的**处理器单元**（Processing Unit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。

然后是一个包含指令寄存器（Instruction Reigster）和程序计数器（Program Counter）的**控制器单元**（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的CPU。

接着是用来存储数据（Data）和指令（Instruction）的内存。以及更大容量的外部存储，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。

最后就是各种输入和输出设备，以及对应的输入和输出机制。

任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。

![冯诺依曼体系结构](E:\Jennifer\other\notes\media\冯诺依曼体系结构.png)

计算机的性能

什么是性能

指标1：响应时间/执行时间

是响应时间的提升却没有那么容易，因为CPU的性能提升其实在10年前就处于“挤牙膏”的状态了

指标2：吞吐率/带宽

提升吞吐率的办法有很多。大部分时候，我们只要多加一些机器，多堆一些硬件就好了。

我们一般把性能，定义成响应时间的倒数

计算机的计时单位：CPU时钟

用时间来衡量时，有两个问题：

1. 是时间不“准”，Linux下有一个叫time的命令，它会返回三个值，第一个是real time，也就是我们说的Wall Clock Time，也就是运行程序整个过程的时间；第二个是user time，也就是CPU在运行你的程序，在用户态运行指令的时间；第三个是sys time，是CPU在运行你的程序，在操作系统内核里运行指令的时间。而程序实际花费的CPU执行时间（CPU Time），就是user time加上sys time。
2. 即使我们已经拿到了CPU时间，我们也不一定可以直接“比较”出两个程序的性能差异。即使在同一台计算机上，CPU可能满载运行也可能降频运行，降频运行的时候自然花的时间会多一些。除了CPU之外，时间这个性能指标还会受到主板、内存这些其他相关硬件的影响。

所以，我们需要对“时间”这个我们可以感知的指标进行拆解，把程序的CPU执行时间变成 CPU时钟周期数（CPU Cycles）和 时钟周期时间（Clock Cycle）的乘积。

```
程序的CPU执行时间=CPU时钟周期数×时钟周期时间
```

时钟周期时间：主频（Frequency/Clock Rate）为2.8GHz的电脑，我们可以先粗浅地认为，CPU在1秒时间内，可以执行的简单指令的数量是2.8G条。即这个2.8GHz就代表，我们CPU的一个“钟表”能够识别出来的最小的时间间
隔。这个时钟周期时间，就是1/2.8G。我们的CPU，是按照这个“时钟”提示的时间来进行自己的操作。主频越高，意味着这个表走得越快，我们的CPU也就“被逼”着走得越快。

“超频”这个概念说的其实就相当于把买回来的CPU内部的钟给调快了，于是CPU的计算跟着这个时钟的节奏，也就自然变快了。当然这个快不是没有代价的，CPU跑得越快，散热的压力也就越大。就和人一样，超过生理极限，CPU就会崩溃了。

对于CPU时钟周期数，我们可以再做一个分解，把它变成“指令数×每条指令的平均时钟周期数（Cycles	PerInstruction，简称CPI）”。不同的指令需要的Cycles是不同的，加法和乘法都对应着一条CPU指令，但是乘法需要的Cycles就比加法要多，自然也就慢。在这样拆分了之后，我们的程序的CPU执行时间就可以变成这样三个部分的乘积。

```
程序的CPU执行时间=指令数×CPI×Clock	Cycle	Time
```

因此，如果我们想要解决性能问题，其实就是要优化这三者。
1. 时钟周期时间，就是计算机主频，这个取决于计算机硬件。我们所熟知的摩尔定律就一直在不停地提高我们计算机的主频。
2. 每条指令的平均时钟周期数CPI，就是一条指令到底需要多少CPU	Cycle。在后面讲解CPU结构的时候，我们会看到，现代的CPU通过流水线技术（Pipeline），让一条指令需要的CPU	Cycle尽可能地少。因此，对于CPI的优化，也是计算机组成和体系结构中的重要一环。
3. 指令数，代表执行我们的程序到底需要多少条指令、用哪些指令。这个很多时候就把挑战交给了编译器。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。

我们可以把自己想象成一个CPU，坐在那里写程序。计算机主频就好像是你的打字速度，打字越快，你自然可以多写一点程序。CPI相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少。如果三者皆能实现，你自然可以很快地写出一个优秀的程序，你的“性能”从外面来看就是好的。















