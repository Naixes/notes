# 基本原理

## 响应式原理

https://juejin.im/post/5a734b6cf265da4e70719386#heading-0

**vue实例初始化中data初始化时(initData(vm))通过`Observer`类将vue的`data`变成响应式**，即为每一个data都利用`Object.defineProperty()`实现了getter/setter方法，用于进行依赖收集和通知更新。

Observer类的walk()做的是遍历data对象中的每一设置的数据，defineReactive ()将其转为`setter/getter`。（new Observer(value) ）

为每个data声明一个`dep`实例对象（vue1.0是这样的，但是data过多时会有性能上的问题，2.0时改为一个组件对应一个`dep`对象，组件更新时会进行diff更新）

get

1. `dep`被对应的data给闭包引用了。举例来说就是每次对`counter`取值或修改时，它的dep实例都可以访问到，不会消失。
2. 在取值之前，根据`Dep.target`来判断是否收集依赖。dep.depend()

set

1. 对数据的值进行修改 
2. 即通过dep实例通知观察者我的数据更新了，dep.notify()

**随后进行`watch`的初始化(initWatch(vm: Component, watch: Object ))，创建Watcher实例**

Watcher：（new Watcher(vm, expOrFn, cb, options) ）

1. 构造函数：`this.deps = [] // 保存观察数据当前的dep实例对象 `

2. 获取对象的getter方法

3. get

   Dep.target = this，把Dep.target设置为该Watcher实例 ，Dep.target是个全局变量，一旦设置了在观察数据中的getter方法就可使用了

   调用getter方法，用来获取观察对象的值，并触发它的依赖收集。

   依赖收集完成后，重置Dep.target=null ，清除旧的deps

![Observer-Watcher-rel](https://user-gold-cdn.xitu.io/2018/2/2/1615530034cf9353?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

- 红色箭头：Watcher类实例化，调用watcher实例的`get()`方法，并设置`Dep.target`为当前watcher实例，触发观察对象的`getter`方法。
- 蓝色箭头：`counter`对象的`getter`方法被触发，调用`dep.depend()`进行依赖收集并返回`counter`的值。依赖收集的结果：**1.counter闭包的dep实例的subs添加观察它的watcher实例w1**；**2. w1的deps中添加观察对象counter的闭包dep**。
- 橙色箭头：当`counter`的值变化后，触发`subs`中观察它的w1执行`update()`方法，最后实际上是调用w1的回调函数cb。

**Dep类**

```js
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;
  constructor () {
    this.id = uid++
    // 保存观察者watcher实例的数组
    this.subs = []
  }
  // 添加观察者
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }
  // 移除观察者
  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }
  // 进行依赖收集
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
  // 通知观察者数据有变化
  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```

Dep类比较简单，对应方法也非常直观，这里最主要的就是维护了保存有观察者实例watcher的一个数组`subs`。

`Watcher`，`Dep`，`Observer`这几个类之间的关系？

A1：`Watcher`是观察者观察经过`Observer`封装过的数据，`Dep`是`Watcher`和观察数据间的纽带，主要起到依赖收集和通知更新的作用。

`Dep`中的`subs`存储的是什么？

A2: `subs`存储的是观察者Watcher实例。

`Watcher`中的`deps`存储的是什么？

A3：`deps`存储的是观察数据闭包中的`dep`实例。

`Dep.target`是什么， 该值是何处赋值的？

A4：`Dep.target`是全局变量，保存当前的watcher实例，在`new Watcher()`的时候进行赋值，赋值为当前Watcher实例。 

- 简单实现

Vue 内部使用了 `Object.defineProperty()` 来实现数据响应式，通过这个函数可以监听到 `set` 和 `get` 的事件。

```js
var data = { name: 'yck' }
observe(data)
let name = data.name // -> get value
data.name = 'yyy' // -> change value

// 添加监视
function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
  })
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  // Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可配置
    configurable: true,
    // 自定义函数
    get: function reactiveGetter() {
      console.log('get value')
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
    }
  })
}
```

以上代码简单的实现了如何监听数据的 `set` 和 `get` 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。

```html
<div>
    {{name}}
</div>
```

在解析如上模板代码时，遇到 `{{name}}` 就会进行依赖收集。

接下来我们先来实现一个 `Dep` 类，用于解耦属性的依赖收集和派发更新操作。

```js
// 通过 Dep 解耦属性的依赖和更新操作
class Dep {
  constructor() {
    this.subs = []
  }
  // 添加依赖
  addSub(sub) {
    this.subs.push(sub)
  }
  // 更新
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null
```

以上的代码实现很简单，当需要依赖收集的时候调用 `addSub`，当需要派发更新的时候调用 `notify`。

接下来我们先来简单的了解下 Vue 组件挂载时添加响应式的过程。**在组件挂载时，会先对所有需要的属性调用 `Object.defineProperty()`，然后实例化 `Watcher`，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。**

接下来的代码简略的表达触发依赖收集时的操作

```js
class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this
    this.cb = cb
    this.obj = obj
    this.key = key
    // 触发属性的 getter 添加监听
    this.value = obj[key]
    Dep.target = null
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key]
    // 调用 update 方法更新 Dom
    this.cb(this.value)
  }
}
```

以上就是 `Watcher` 的简单实现，在执行构造函数的时候将 `Dep.target` 指向自身，从而使得收集到了对应的 `Watcher`，在派发更新的时候取出对应的 `Watcher` 然后执行 `update` 函数。

接下来，需要对 `defineReactive` 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。

```js
function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  let dp = new Dep()
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      console.log('get value')
      // 将 Watcher 添加到订阅
      if (Dep.target) {
        dp.addSub(Dep.target)
      }
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
      // 执行 watcher 的 update 方法
      dp.notify()
    }
  })
}
```

以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。

现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。

```js
var data = { name: 'yck' }
// 添加监视
// 首先对所有需要的属性调用 Object.defineProperty()
observe(data)
function update(value) {
  document.querySelector('div').innerText = value
}
// 模拟解析到 `{{name}}` 触发的操作
// 然后实例化 Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。
new Watcher(data, 'name', update)
// update Dom innerText
data.name = 'yyy' 
```

### Object.defineProperty 的缺陷

以上已经分析完了 Vue 的响应式原理，接下来说一点 `Object.defineProperty` 中的缺陷。

如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 `Object.defineProperty` 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。

对于第一个问题，Vue 提供了一个 API 解决

```js
export function set (target: Array<any> | Object, key: any, val: any): any {
  // 判断是否为数组且下标是否有效
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 调用 splice 函数触发派发更新
    // 该函数已被重写
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  // 判断 key 是否已经存在
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  // 如果对象不是响应式对象，就赋值返回
  if (!ob) {
    target[key] = val
    return val
  }
  // 进行双向绑定
  defineReactive(ob.value, key, val)
  // 手动派发更新
  ob.dep.notify()
  return val
}
```

对于数组而言，Vue 内部重写了以下函数实现派发更新

```js
// 获得数组原型
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
// 重写以下函数
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
methodsToPatch.forEach(function (method) {
  // 缓存原生函数
  const original = arrayProto[method]
  // 重写函数
  def(arrayMethods, method, function mutator (...args) {
  // 先调用原生函数获得结果
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    // 调用以下几个函数时，监听新数据
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // 手动派发更新
    ob.dep.notify()
    return result
  })
})
```

## 虚拟DOM

作用：合并请求，快速查询，局部刷新

## 编译过程

想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？

首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为 `render` 函数，然后通过执行 `render` 函数生成 Virtual DOM 最终映射为真实 DOM。

接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为：

1. 将模板解析为 AST
2. 优化 AST
3. 将 AST 转换为 `render` 函数

在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象

```js
{
    // 类型
    type: 1,
    // 标签
    tag,
    // 属性列表
    attrsList: attrs,
    // 属性映射
    attrsMap: makeAttrsMap(attrs),
    // 父节点
    parent,
    // 子节点
    children: []
}
```

然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。

当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 [Content Model](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FGuide%2FHTML%2FContent_categories) 规范等等问题。

接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。

最后一个阶段就是通过 AST 生成 `render` 函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。

## NextTick 原理分析

`nextTick` 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。

在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。

对于实现 macrotasks ，会先判断是否能使用 `setImmediate` ，不能的话降级为 `MessageChannel` ，以上都不行的话就使用 `setTimeout`

```js
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else if (
  typeof MessageChannel !== 'undefined' &&
  (isNative(MessageChannel) ||
    // PhantomJS
    MessageChannel.toString() === '[object MessageChannelConstructor]')
) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () => {
    port.postMessage(1)
  }
} else {
  macroTimerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}
```

以上代码很简单，就是判断能不能使用相应的 API。

# 源码解读

# 源码解读（参照教程资料）

## 概览

内部流程图

![vue流程图](E:\Jennifer\other\notes\media\vue流程图.png)

### 初始化及挂载

在 **new Vue()** 之后。 Vue 会调用 **_init 函数**进行**初始化**，也就是这里的 init 过程，它会初始化生命周
期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过
Object.defineProperty 设置 setter 与 getter 函数，用来实现**「 响应式」**以及**「 依赖收集」**。
初始化之后调用 **$mount 会挂载组件**，如果是运行时编译，即不存在 render function 但是存在
template 的情况，需要进行「 编译」步骤。 

### 编译

compile 编译可以分成 parse、 optimize 与 generate 三个阶段，最终需要**得到 render function**。 

#### parse（解析）

parse 会用正则等方式**解析 template 模板**中的指令、class、style 等数据，**形成 AST**。 

#### optimize（优化）

optimize 的主要作用是**标记 static 静态节点**，这是 Vue 在编译过程中的一处优化，后面当 update 更新
界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化
了 patch 的性能。 

#### generate（生成）

generate 是**将 AST 转化成 render function 字符串**的过程，得到结果是 render 的字符串以及
staticRenderFns 字符串。 

在经历过 parse、 optimize 与 generate 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render
function 了。 

### 响应式

这里的 getter 跟 setter 已经在之前介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，
它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。
当 render function 被**渲染的时候**，因为会读取所需对象的值，所以会**触发 getter 函数进行「 依赖收**
**集」**，「 依赖收集」的目的是**将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中**。
形成如下所示的这样一个关系。 

![依赖收集](E:\Jennifer\other\notes\media\依赖收集.png)

在修改对象的值的时候，会触发对应的 setter， setter 通知之前「 依赖收集」得到的 Dep 中的每一个
Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来
更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略。 

### Virtual DOM

我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 

```js
{
    tag: 'div',                 /*说明这是一个 div 标签*/
    children: [                 /*存放该标签的子节点*/
        {
            tag: 'a',           /*说明这是一个 a 标签*/
            text: 'click me'    /*标签的内容*/
        }
    ]
}
```

实际的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、isComment （代表是否为注释节点）等。 

### 更新视图

在修改一个对象值的时候，会通过 **setter ‐> Watcher ‐> update** 的流程来修改对应的视图，那么最终是如何更新视图的呢？ 

当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM中。但是其实我们只对其中的一小块内容进行了修改，能不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的**「 patch 」**了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 **diff 算法**得出它们的「 差异」。最后我们只需要将这些「 差异」的对应 DOM 进行修改即可。 

## 响应式系统的基本原理

### 响应式系统

#### Object.defineProperty

```js
/*
    obj: 目标对象
    prop: 需要操作的目标对象的属性名
    descriptor: 描述符
     
    return value 传入对象
*/
Object.defineProperty(obj, prop, descriptor)
```

descriptor 的一些属性，简单介绍几个属性，具体可以参考 MDN 文档。

- enumerable，属性是否可枚举，默认 false。
- configurable，属性是否可以被修改或者删除，默认 false。
- get，获取属性的方法。
- set，设置属性的方法。 

#### 实现 observer（可观察的） 

在 **init 的阶段**会进行初始化，对数据进行「 响应式化」。 

我们不考虑数组等复杂的情况，只对对象进行处理。首先定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法。 

```js
// 这个函数用来模拟视图更新
function cb (val) {
    /* 渲染视图 */
    console.log("视图更新啦～");
}
// 然后我们定义一个 defineReactive ，这个方法通过 Object.defineProperty 来实现对对象的「 响应式」化，入参是一个 obj（需要绑定的对象）、key（obj 的某一个属性），val（具体的值）。
// 经过 defineReactive 处理以后，我们的 obj 的 key 属性在「读」的时候会触发 reactiveGetter 方法，而在该属性被「写」的时候则会触发 reactiveSetter 方法。 
function defineReactive (obj, key, val) {
    Object.defineProperty(obj, key, {
        enumerable: true,       /* 属性可枚举 */
        configurable: true,     /* 属性可被修改或删除 */
        get: function reactiveGetter () {
            return val;         /* 实际上会依赖收集 */
        },
        set: function reactiveSetter (newVal) {
            if (newVal === val) return;
            cb(newVal);
        }
    });
}
// 我们还需要在上面再封装一层 observer 。这个函数传入一个 value（需要「响应式」化的对象），通过遍历所有属性的方式对该对象的每一个属性都通过 defineReactive 处理。 
function observer (value) {
    if (!value || (typeof value !== 'object')) {
        return;
    }
     
    Object.keys(value).forEach((key) => {
        defineReactive(value, key, value[key]);
    });
}
// 对 options 的 data 进行处理，这里的 data 就是平时我们在写Vue 项目时组件中的 data 属性（实际上是一个函数，这里当作一个对象来简单处理）。 
class Vue {
    /* Vue 构造类 */
    constructor(options) {
        this._data = options.data;
        // 会注册 getter
        observer(this._data);
    }
}
// 我们只要 new 一个 Vue 对象，就会将 data 中的数据进行「响应式」化。如果我们对 data 的属性进行下面的操作，就会触发 cb 方法更新视图。 
let o = new Vue({
    data: {
        test: "I am test."
    }
});
o._data.test = "hello,world.";  /* 视图更新啦～ */
```

### 依赖收集追踪原理

#### 为什么要依赖收集？

1. 修改了视图中并不需要用到 data 时，我们并不需要触发上一章所讲的 cb 函数来更新视图，调用 cb 显然是不正确的。 

2. 假设我们现在有一个全局的对象，我们可能会在多个 Vue 对象中用到它进行展示。对象修改时 我们应该需要通知用到它的 vm 实例进行视图的更新。 

#### 订阅者 Dep

```js
// 它的主要作用是用来存放 Watcher 观察者对象。 
class Dep {
    constructor () {
        /* 用来存放 Watcher 对象的数组 */
        this.subs = [];
    }
    /* 在 subs 中添加一个 Watcher 对象 */
    addSub (sub) {
        this.subs.push(sub);
    }
    /* 通知所有 Watcher 对象更新视图 */
    notify () {
        this.subs.forEach((sub) => {
            sub.update();
        })
    }
}
```

主要是两件事情：
1. 用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作；
2. 用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。 

#### 观察者 Whatcher

```js
class Watcher {
    constructor () {
        /* 在 new 一个 Watcher 对象时将该对象赋值给 Dep.target，在 get 中会用到 */
        Dep.target = this;
    }
    /* 更新视图的方法 */
    update () {
        console.log("视图更新啦～");
    }
}
Dep.target = null;
```

#### 依赖收集

```js
// 我们在闭包中增加了一个 Dep 类的对象，用来收集 Watcher 对象。在对象被「读」的时候，会触发 reactiveGetter 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。之后如果当该对象被「写」的时候，则会触发 reactiveSetter 方法，通知 Dep 类调用 notify 来触发所有 Watcher 对象的 update 方法更新对应视图。 
function defineReactive (obj, key, val) {
    /* 一个 Dep 类对象:这个对象用来存放 Watcher 对象的实例。 */
    const dep = new Dep();
     
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () {
            /* 将 Dep.target（即当前的 Watcher 对象存入 dep 的 subs 中） */
            dep.addSub(Dep.target);
            return val;          
        },
        set: function reactiveSetter (newVal) {
            if (newVal === val) return;
            /* 在 set 的时候触发 dep 的 notify 来通知所有的 Watcher 对象更新视图 */
            dep.notify();
        }
    });
}
class Vue {
    constructor(options) {
        this._data = options.data;
        // 注册 getter 等
        observer(this._data);
        /* 新建一个 Watcher 观察者对象，这时候 Dep.target 会指向这个 Watcher 对象 */
        new Watcher();
        /* 在这里模拟 render 的过程，为了触发 test 属性的 get 函数 */
        console.log('render~', this._data.test);
    }
}
```

首先在 observer 的过程中会注册 get 方法，该方法用来进行「 依赖收集」。在它的闭包中会有一个 Dep 对
象，这个对象用来存放 Watcher 对象的实例。其实「 依赖收集」的过程就是**把 Watcher 实例存放到对**
**应的 Dep 对象中去**。 get 方法可以让当前的 Watcher 对象（Dep.target）存放到它的 subs 中（addSub）
方法，在数据变化时， set 会调用 Dep 对象的 notify 方法通知它内部所有的 Watcher 对象进行视图更新。
这是 Object.defineProperty 的 set/get 方法处理的事情

那么「 依赖收集」的**前提条件**还有两个：

1. 触发 get 方法；
2. 新建一个 Watcher 对象。

这个我们在 Vue 的构造类中处理。新建一个 Watcher 对象只需要 new 出来，这时候 Dep.target 已经指向了这个 new 出来的 Watcher 对象来。而触发 get 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取 test 来触发 get 进行「依赖收集」。

## 实现 Virtual DOM 下的一个 VNode 节点

### 什么是 VNode 

我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 

### 实现一个 VNode 

VNode 归根结底就是一个 JavaScript 对象，只要这个类的一些属性可以正确直观地描述清楚当前节点的信息即可。我们来实现一个简单的 VNode 类，加入一些基本属性，先不考虑复杂的情况。 

```js
class VNode {
    constructor (tag, data, children, text, elm) {
        /*当前节点的标签名*/
        this.tag = tag;
        /*当前节点的一些数据信息，比如 props、attrs 等数据*/
        this.data = data;
        /*当前节点的子节点，是一个数组*/
        this.children = children;
        /*当前节点的文本*/
        this.text = text;
        /*当前虚拟节点对应的真实 dom 节点*/
        this.elm = elm;
    }
}
```

比如我目前有这么一个 Vue 组件。

```html
<template>
  <span class="demo" v‐show="isShow">
    This is a span.
  </span>
</template>
```

```js
// 用js代码的形式
function render () {
    return new VNode(
        'span',
        {
            /* 指令集合数组 */
            directives: [
                {
                    /* v‐show 指令 */
                    rawName: 'v‐show',
                    expression: 'isShow',
                    name: 'show',
                    value: true
                }
            ],
            /* 静态 class */
            staticClass: 'demo'
        },
        [ new VNode(undefined, undefined, undefined, 'This is a span.') ]
    );
}
// 转换为Vnode
{
    tag: 'span',
    data: {
        /* 指令集合数组 */
        directives: [
            {
                /* v‐show 指令 */
                rawName: 'v‐show',
                expression: 'isShow',
                name: 'show',
                value: true
            }
        ],
        /* 静态 class */
        staticClass: 'demo'
    },
    text: undefined,
    children: [
        /* 子节点是一个文本 VNode 节点 */
        {
            tag: undefined,
            data: undefined,
            text: 'This is a span.',
            children: undefined
        }
    ]
}
```

然后我们可以将 VNode 进一步封装一下，可以实现一些产生常用 VNode 的方法。 

```js
// 创建一个空节点 
function createEmptyVNode () {
    const node = new VNode();
    node.text = '';
    return node;
}
// 创建一个文本节点 
function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val));
}
// 克隆一个 VNode 节点
function cloneVNode (node) {
    const cloneVnode = new VNode(
        node.tag,
        node.data,
        node.children,
        node.text,
        node.elm
    );
    return cloneVnode;
}
```

总的来说，VNode 就是一个 JavaScript 对象，用 JavaScript 对象的属性来描述当前节点的一些状态，
用 VNode 节点的形式来模拟一棵 Virtual DOM 树。 

## template 模板是怎样通过 Compile 编译的 

### Compile

**compile 编译可以分成 parse、 optimize 与 generate 三个阶段，最终需要得到 render function。**这部分内容不算 Vue.js 的响应式核心，只是用来编译的，把握如何解析的大致流程即可。 

由于解析过程比较复杂，通过一个示例的变化来看解析的过程。解析的过程及结果都是将最重要的部分抽离出来展示。 

```html
<div :class="c" class="demo" v‐if="isShow">
    <span v‐for="item in sz">{{item}}</span>
</div>
var html = '<div :class="c" class="demo" v‐if="isShow"><span v‐for="item in sz">{{item}}</span></div>';
```

### parse

首先是 parse， parse 会用正则等方式将 template 模板中进行**字符串解析**，得到指令、class、style 等数据，**形成 AST**（ 在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。）。 

这个过程比较复杂，会涉及到比较多的正则进行字符串解析，我们来看一下得到的 AST 的样子。 

```js
{
    /* 标签属性的 map，记录了标签上属性 */
    'attrsMap': {
        ':class': 'c',
        'class': 'demo',
        'v‐if': 'isShow'
    },
    /* 解析得到的:class */
    'classBinding': 'c',
    /* 标签属性 v‐if */
    'if': 'isShow',
    /* v‐if 的条件 */
    'ifConditions': [
        'exp': 'isShow'
    ],
    /* 标签属性 class */
    'staticClass': 'demo',
    /* 标签的 tag */
    'tag': 'div',
    /* 子标签数组 */
    'children': [
        {
            'attrsMap': {
                'v‐for': "item in sz"
            },
            /* for 循环的参数 */
            'alias': "item",
            /* for 循环的对象 */
            'for': 'sz',
            /* for 循环是否已经被处理的标记位 */
            'forProcessed': true,
            'tag': 'span',
            'children': [
                {
                    /* 表达式，_s 是一个转字符串的函数 */
                    'expression': '_s(item)',
                    'text': '{{item}}'
                }
            ]
        }
    ]
}
```

最终得到的 AST 通过一些特定的属性，能够比较清晰地描述出标签的属性以及依赖关系。 

#### 正则

```js
const ncname = '[a‐zA‐Z_][\\w\\‐\\.]*';
const singleAttrIdentifier = /([^\s"'<>/=]+)/
const singleAttrAssign = /(?:=)/
const singleAttrValues = [
  /"([^"]*)"+/.source,
  /'([^']*)'+/.source,
  /([^\s"'=<>`]+)/.source
]
const attribute = new RegExp(
  '^\\s*' + singleAttrIdentifier.source +
  '(?:\\s*(' + singleAttrAssign.source + ')' +
  '\\s*(?:' + singleAttrValues.join('|') + '))?'
)
const qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')'
const startTagOpen = new RegExp('^<' + qnameCapture)
const startTagClose = /^\s*(\/?)>/
const endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>')
const defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g
const forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/
```

### advance 

因为我们解析 template 采用循环进行字符串匹配的方式，所以每匹配解析完一段我们需要将已经匹配掉的去掉，头部的指针指向接下来需要匹配的部分。 

```js
function advance (n) {
    index += n
    html = html.substring(n)
}
```

#### parseHTML

首先我们需要定义个 parseHTML 函数，在里面我们循环解析 template 字符串。

```js
function parseHTML () {
    // parseHTML 会用 while 来循环解析 template ，用正则在匹配到标签头、标签尾以及文本的时候分别进行不同的处理。直到整个 template 被解析完毕。 
    while(html) {
        let textEnd = html.indexOf('<');
        // 以标签开头
        if (textEnd === 0) {
            // 结束标签
            // match：正则提取，返回数组
            if (html.match(endTag)) {
                //...process end tag
                continue;
            }
            // 开始标签的开头
            if (html.match(startTagOpen)) {
                //...process start tag
                continue;
            }
        } else {
            //...process text
            continue;
        }
    }
}            
```

#### parseStartTag

我们来写一个 parseStartTag 函数，用来解析起始标签（`<div :class="c" class="demo" v‐if="isShow">`部分的内容）。   

```js
function parseStartTag () {
    // 首先用 startTagOpen 正则得到标签的头部，可以得到 tagName（标签名称） 
    const start = html.match(startTagOpen);
    if (start) {
        const match = {
            tagName: start[1],
            // 同时我们需要一个数组 attrs 用来存放标签内的属性。
            attrs: [],
            start: index
        }
        advance(start[0].length);
        // 接下来使用 startTagClose 与 attribute 两个正则分别用来解析标签结束以及标签内的属性。这段代码用 while 循环一直到匹配到 startTagClose 为止，解析内部所有的属性。 
        let end, attr
        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
            advance(attr[0].length)
            match.attrs.push({
                name: attr[1],
                value: attr[3]
            });
        }
        if (end) {
            match.unarySlash = end[1];
            advance(end[0].length);
            match.end = index;
            return match
        }
    }
}
```

### stack

此外，我们需要维护一个 stack 栈来保存已经解析好的标签头，这样我们可以根据在解析尾部标签的时候得到所属的层级关系以及父标签。同时我们定义一个 **currentParent 变量**用来存放当前标签的父标签节点的引用， **root 变量**用来指向根标签节点。 

```js
const stack = [];
let currentParent, root;
```

知道这个以后，我们优化一下 parseHTML ，在 startTagOpen 的 if 逻辑中加上新的处理。 

```js
if (html.match(startTagOpen)) {
    const startTagMatch = parseStartTag();
    const element = {
        type: 1,
        tag: startTagMatch.tagName,
        lowerCasedTag: startTagMatch.tagName.toLowerCase(),
        attrsList: startTagMatch.attrs,
        attrsMap: makeAttrsMap(startTagMatch.attrs),
        parent: currentParent,
        children: []
    }
    if(!root){
        root = element
    }
    if(currentParent){
        currentParent.children.push(element);
    }
    stack.push(element);
    currentParent = element;
    continue;
}
```





































































