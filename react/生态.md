## 路由

react-router-dom

```js
import {BrowserRouter as Router, Route, Link} from 'react-router-dom'
...
```

```jsx
import React from 'react'
// BrowserRouter，以path为键，需要服务器支持，刷新会请求服务器
// HashRouter，以哈希值为键，路由根容器，所有与路由相关的东西都包裹在它里面，一个网站只需要一个
// MemoryRouter，路由信息保存在内存中，刷新后状态不会保留，应用：RN
// Route，表示路由规则，重要的属性path， component
// Link，路由链接，有to属性
// redirect 和link类似也是一个标签，会自动跳转，可以用三目控制
import {HashRouter, Route, Link} from 'react-router-dom'

export default class app extends React.Component{
    constructor(props) {
        super(props)
        this.state = {}
    }
    render() {
        // 使用HashRouter包裹表示使用路由，路径中多了＃，只需要使用一次
        // HashRouter中只能有一个根元素
        return
        <HashRouter>
            <div>
            	<Link to="/home"></h1>
            	<Link to="/movie"></h1>
            	<Link to="/about"></h1>
            </div>
            <hr/>
        	{/* 路由规则以及组件位置占位符 */}
            {/* 默认的路由匹配是模糊匹配，部分匹配也可以成功，加上exact属性表示精确匹配,精确匹配也会从上到下依次匹配 */}
            <Route path="/home" component={Home}></Route>
            {/* 使用:匹配参数 */}
            <Route path="/movie/:type/:id" component={Movie} exact></Route>
            <Route path="/about" component={About}></Route>
        </HashRouter>
    }
}
```

route：表示路由规则，自带三个 render method 和三个 props 。 

`<Route component> `

`<Route render> `

`<Route children> `

```
match
location
history
```

### 路由传参

使用:匹配参数 

`<Route path="/movie/:type/:id" component={Movie} exact></Route>`

获取参数，可以把路由参数保存到state中去，但是参数改变不会让组件销毁重新渲染，需要在componentDidUpdate中更新，由于state，props更新都会update，会导致重复更新，直接使用props更新不会有这个问题

`{this.props.match.params.type}`

```js
componentDidUpdate(old_props, old_state){
    // 判断是否更新
    if (old_state.id === this.props.match.params.id) {
        // 一般是获取数据，更新数据
        this.setState({
            // 设置状态也会导致update
            // props.location.params也行
            id: this.props.match.params.id
        })
    }
}
```

不提供query的传参可以自己解析，一般不会用，会导致页面刷新

### 嵌套路由

在组件中继续添加路由path需要包含父级路由，直接写不好维护，可以使用this.props.match.path

在父级设置默认路由：直接修改path

```jsx
render() {
    const path = this.props.match.path

    return (
        <div>
            {/* 嵌套路由 */}
            <Link to={`${path}/inter`}>国际</Link>
            <Link to={`${path}/society`}>社会</Link>

            <Route path={`${path}/inter`} componet={inter}></Route>
            <Route path={`${path}/society`} componet={society}></Route>
        </div>
	)
}
```

### 应用

通过路由跳转的方式显示模态框，防止刷新关闭，如果还想保存数据，可以写到localstorage里。

问题：跳转时也会请求数据，解决：将数据放到redux中

利用ref获取表单数据

问题：提交数据时如果使用原来的：window.location='xxx'，会导致页面刷新重新访问接口，解决：使用Link，但是处理失败有问题（不能阻止跳转）；使用编程式导航

删除：封装提示框，不用使用路由跳转，使用状态

封装数据通信

### 编程式导航 

需要用到withRouter：`import {withRouter} from 'reacte-router-dom' ... export default withRouter(Component)`

`this.props.hisory.push('')`

### switch组件

```jsx
import {HashRouter, Route, Link, Switch} from 'react=router-dom'

// 表示已经匹配到一个路由的情况下不再继续匹配
<Switch>
    <Route exact path="" component={}></Route>
    <Route exact path="" component={}></Route>
    <Route exact path="" component={}></Route>
</Switch>
```

## 

## Redux

provider：包在最外面

connect：状态映射，合并冲突

reducer：状态对象

状态更新：action

npm i redux react-redux -D

```js
import {createStore} from 'redux'
import {Provider} from 'react-redux'

// 初始化和每次更新状态对象都会执行
function reducer1(state, action) {
    if(!state) {
        // 初始化
    }
    return state
}
// 简写
// 传入旧状态返回新状态
function reducer1(state={xxx}, action) {
    return state
}
// 创建存储对象
const store = createStore(reducer1)
// 用<Provider>包装根组件传入store对象store = {store}
// 使用
import {connect} from 'react-redux'
// export default App
// state来自reducer，props来自组件
// 只能接收不能修改，单向数据流，组件内也不能赋值
export default connect(function(state, props){
    // 混合，解决冲突
    // 使用state，组件props中会包含state的内容
    return state
    return {
        ...state,
        // 会重复的属性使用props
		name: props.name
        // 都进行保留
        name: [state.name, props.name]
    }
}, {
	// 当做组件的一部分，用props访问使用
    // 参数自定义
    setName(name) {
    	// 必须return，返回值为action，在reducer中
        return {
			type: 'set_name',
            name
        }
	}
})(App)
// reducer
function reducer1(state={xxx}, action) {
    if(action.type === 'set_name') {
        return {
            ...state,
            name: action.name
        }
    }
    // 要返回一个新的state
    return state
}
// 优化
// 单独的actions.js，找不到时会报错
export const SET_NAME = 'set_name'
// 单独的store.js
// 多个reducer
import {combineReducers} from 'redux'
let reducers = combineReducers({
    user: reducer1,
    comp: reducer2
})
export default createStorer(reducers)
// 修改相应的映射，修改时会触发所有的reducer
// 分模块，分成单独的文件

```

基本思想：单向数据流

state-》（component）props-》action-》state

## AntDesign框架UI

electron使用js，html，css的跨平台桌面应用

1. 运行`npm install antd --save`安装ant design
2. 导入相关组件：

```
import { DatePicker } from 'antd';
```

1. 导入样式：

```
import 'antd/dist/antd.css';
```

### 实现ANT组件的按需加载

1. 运行`cnpm i babel-plugin-import --save-dev`
2. 修改`.babelrc`文件：

```
{
    "presets":["es2015", "stage-0", "react"],
    "plugins":[
        "transform-runtime",
        ["import", { "libraryName": "antd", "style": "css" }]
    ]
}
```

3. 然后只需从 antd 引入模块即可，**无需单独引入样式**。`babel-plugin-import`自动解析成手动引入的代码。

**最新版：**

`antd` 默认支持基于 ES modules 的 tree shaking，对于 js 部分，直接引入 `import { Button } from 'antd'` 就会有按需加载的效果。

如果你在开发环境的控制台看到下面的提示，那么你可能还在使用 `webpack@1.x` 或者 tree shaking 失效，请升级或检查相关配置。

```null
You are using a whole package of antd, please use https://www.npmjs.com/package/babel-plugin-import to reduce app bundle size.
```

### 组件

分页