## React中创建组件

### function组件

> **使用构造函数来创建组件**，如果要接收外界传递的数据，需要在构造函数的参数列表中使用`props`来接收；
>
> 必须要向外return一个合法的JSX创建的虚拟DOM；

- 创建组件：

  ```jsx
  function Hello (props) { 
  	// return null 
  	return <div>Hello 组件</div>
  }
  ```

- 为组件传递数据：

  ```jsx
  // 使用组件并为组件传递 props 数据
  <Hello name={dog.name} age={dog.age} gender={dog.gender}></Hello>
  <Hello {...dog}></Hello>
  
  // 在构造函数中，使用 props 形参，接收外界传递过来的数据
  function Hello(props) {
    // props.name = 'zs'
    console.log(props)
    // 结论：不论是 Vue 还是 React，组件中的 props 永远都是只读的；不能被重新赋值；
    return <div>这是 Hello 组件 --- {props.name} --- {props.age} --- {props.gender}</div>
  }
  ```


1. 父组件向子组件传递数据

2. 使用{...obj}属性扩散传递数据

3. 将组件封装到单独的文件中

4. 注意：组件的名称首字母必须是大写

5. 在导入组件的时候，如何省略组件的`.jsx`后缀名：

   ```js
   // 打开 webpack.config.js ，并在导出的配置对象中，新增 如下节点：
   resolve: {
       extensions: ['.js', '.jsx', '.json'], // 表示，这几个文件的后缀名，可以省略不写
       alias: {
           '@': path.join(__dirname, './src')
       }
     }
   ```

6. 在导入组件的时候，配置和使用`@`路径符号

#### 状态管理

```js
import { useState, useEffect } from "react"; 
function ClockFunc() { 
    // useState创建一个状态和修改该状态的函数 
    const [date, setDate] = useState(new Date()); 
    // useEffect编写副作用代码 
    useEffect(() => { 
        // 启动定时器是我们的副作用代码 
        const timerID = setInterval(() => { setDate(new Date()); }, 1000); 
        // 返回清理函数 
        return () => clearInterval(timerID); 
    }, []);
    // 参数2传递空数组使我们参数1函数仅执行一次 
    return <div>{date.toLocaleTimeString()}</div>; 
}
```

### class组件

#### ES6中 class 关键字的使用

1. class 中 `constructor` 的基本使用
2. 实例属性和实例方法
3. 静态属性和静态方法

```javascript
// 在类中只能写构造器实例静态方法和属性
// 本质和之前的构造函数一致
class Animal {
    // 每一个类都有构造器，没有指定时有默认的构造器
    // new的时候优先执行构造器中的代码
    constructor(参数1, 参数2) {
        // 实例属性
        this.aa = 参数1
        this.bb = 参数2
    }
    // 静态属性，通过构造函数调用
    static name = 'name'
	// 实例方法
	foo() {}
	// 静态方法
	static foo() {}
}
```

4. 使用 `extends` 关键字实现继承

```javascript
class Person {}
class Chinese extends Person{
    constructor(参数1, 参数2) {
        // extends关键字继承的父类，要在构造器最开始调用super()
        // super()是父类构造器的引用
        super(参数1, 参数2)
        this.state={}
    }
    render() {}
}
// 子类可以访问父类的实例方法
```

5. 为子类挂载独有的实例方法和属性

放到super()后面

#### 基于class关键字创建组件

1. 最基本的组件结构：

   ```jsx
   // 如果要使用 class 定义组件，必须 让自己的组件，继承自 React.Component
   class 组件名称 extends React.Component {
       constructor(...args){
           super(...args)
           // 状态：constructor中初始化，要用setState({})修改更新后会重新渲染，同时修改同一个key，只会有一个起作用
           this.state = {
           }
       }
       // 在组件内部，必须有 render 函数,作用：渲染当前组件对应的 虚拟DOM结构
       render(){
           const name = "react study"
           const user = { firstName: "tom", lastName: "jerry" }
           function formatName(user) { 
               return user.firstName + " " + user.lastName;
           }
           const greet = <p>hello, Jerry</p>;
           const arr = [1, 2, 3].map(num => <li key={num}>{num}</li>)
           // render 函数中，必须 返回合法的 JSX 虚拟DOM结构
           return ( 
               <div> 
                   {/* 条件语句 */} 
                   {name ? <h2>{name}</h2> : null} 
                   {/* 函数也是表达式 */} 
                   {formatName(user)} 
                   {/* jsx也是表达式 */} 
                   {greet} 
                   {/* 数组 */} 
                   <ul>{arr}</ul> 
                   {/* 属性 */} 
                   <img src={logo} className={style.img} alt="" /> 
               </div> 
           )
       }
   }
   // 使用<名称></名称>相当与'组件名称'类的实例对象
   ```

传递的参数不用接收，直接使用this.props访问，只读

##### setState特性

- setState是批量执行的，因此对同一个状态执行多次只起一次作用，多个状态更新可以放在同一个 

setState中进行：

```js
componentDidMount() { 
    // 假如couter初始值为0，执行三次以后其结果是多少？ 
    this.setState({counter: this.state.counter + 1}); 
    this.setState({counter: this.state.counter + 1}); 
    this.setState({counter: this.state.counter + 1}); 
}
```

- setState通常是异步的，因此如果要获取到最新状态值有以下三种方式：

1. 传递函数给setState方法，这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数

```js
this.setState((state, props) => ({ counter: state.counter + 1}));// 1 
this.setState((state, props) => ({ counter: state.counter + 1}));// 2 
this.setState((state, props) => ({ counter: state.counter + 1}));// 3
```

2. 使用定时器：

```js
setTimeout(() => { 
    console.log(this.state.counter); 
}, 0);
```

3. 原生事件中修改状态

```js
componentDidMount(){ 
    document.body.addEventListener('click', this.changeValue, false)
}
changeValue = () => { 
    this.setState({counter: this.state.counter+1}) console.log(this.state.counter) 
}
```

### 两种创建组件方式的对比

> 注意：使用 class 关键字创建的组件，有自己的私有数据（this.state） 和生命周期函数；
>
> 注意：使用 function 创建的组件，只有props，没有自己的私有数据和生命周期函数；

1. 用**构造函数**创建出来的组件：叫做“无状态组件”【不需要有自己的私有数据时使用】
2. 用**class关键字**创建出来的组件：叫做“有状态组件”【需要有自己的私有数据时使用】
3. React官方说：无状态组件，由于没有自己的state和生命周期函数，所以运行效率会比有状态组件稍微高一些；

### PropTypes检查属性类型

```react
import PropTypes from 'prop-typs'
...
PriceList.propTypes = {
  items: PropTypes.array.isRequired,
  onModifyItemL: PropTypes.func.isRequired,
  onDeleteItemL: PropTypes.func.isRequired
}

// defaultProps:默认属性
PriceList.defaultProps = {
  onModifyItemL: () => {}
}
```

### 渲染评论列表

![效果](E:/Jennifer/other/notes/react/media/cmtlist.png)

有两个组件，一个父组件一个子组件

#### 通过for循环生成多个组件

```jsx
import React from 'react'
import ReactDOM from 'react-dom'

function CommentsItem(props) {
    return {<div>
        <h1>{props.user}</h1>
    	<p>{props.content}</p>
    </div>)}
}

class Comments extends React.Component {
    constructor() {
        super()
        this.state = CommentList: [
            { id: 1, user: '张三', content: '哈哈，沙发' },
            { id: 2, user: '李四', content: '哈哈，板凳' },
            { id: 3, user: '王五', content: '哈哈，凉席' },
            { id: 4, user: '赵六', content: '哈哈，砖头' },
            { id: 5, user: '田七', content: '哈哈，楼下山炮' }
        ]
    }
    render() {
        return (
            <div>
            	<h1>评论列表</h1>
            	{this.state.CommentList.map(item => <CommentsItem {...item} key={item.id}>				 </CommentsItem>}
        	</div>
		)
    }
}
```

### 组件通信

#### props

传递状态

传递函数：可以把子组件信息传入父组件，这个常称为状态提升

```react
// StateMgt 
<Clock change={this.onChange}/> 
// Clock 
this.timerID = setInterval(() => { 
    this.setState({ date: new Date() }, ()=>{ 
        // 每次状态更新就通知父组件 
        this.props.change(this.state.date); 
    }); 
}, 1000);
```

传递this：

```jsx
let root = document.getElementById("div")
// 父组件向子组件传值，子组件可修改
class Comp extends React.Component{
    constructor(...args){
        super(...args)
        this.state = {
            a: 0
        }
    }
    add(n){
        this.setState({
            a: this.state.a + n
        })
    }
    render() {
        return (
            <div>
                {this.state.a}
                <Sub par={this}/>
            </div>
        )
    }
}
class Sub extends React.Component {
    constructor(...args){
        super(...args)
        this.state = {
        }
    }
    fn(){
        this.props.par.add(1)
    }
    render() {
        return (
            <div>
                <input type="button" value="+1" onClick={this.fn.bind(this)} />
            </div>
        )
    }
}
ReactDOM.render(
    <div className="box">
        <div>
            <Comp a={2}/>
        </div>
    </div>,
    root
)
```

#### ref

```jsx
let root = document.getElementById("div")
// 子组件向父组件传值，父组件可修改
class Comp extends React.Component{
    constructor(...args){
        super(...args)
        this.state = {
        }
    }
    fn(){
        this.refs['sub'].add(1);
    }
    render() {
        return (
            <div>
                <input type="button" value="+1" onClick={this.fn.bind(this)} />
                <Sub ref='sub'/>
            </div>
        )
    }
}
class Sub extends React.Component{
    constructor(...args){
        super(...args)
        this.state = {
            a: 2
        }
    }
    add(n){
        this.setState({
            a: this.state.a + n
        })
    }
    render() {
        return (
            <div>
                {this.state.a}
            </div>
        )
    }
}
ReactDOM.render(
    <div className="box">
        <div>
            <Comp a={2}/>
        </div>
    </div>,
    root
)
```

#### context

跨层级组件之间通信 

```react
// 为当前的 theme 创建一个 context（“light”为默认值）。每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。
const ThemeContext = React.createContext('light');
class App extends React.Component {
  render() {
    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。
    // 无论多深，任何组件都能读取这个值。
    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class ThemedButton extends React.Component {
  // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。
  // React 会往上找到最近的 theme Provider，然后使用它的值。
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}
```

Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。

```react
import React from "react"; 
// 创建上下文 
const Context = React.createContext(); 
// 获取Provider和Consumer 
const Provider = Context.Provider; 
const Consumer = Context.Consumer; 
// Child显示计数器，并能修改它，多个Child之间需要共享数据 
function Child(props) { 
    return <div onClick={() => props.add()}>{props.counter}</div>; 
}
export default class ContextTest extends React.Component { 
    // state是要传递的数据 
    state = { counter: 0 };
	// add方法可以修改状态 
	add = () => { 
        this.setState(nextState => ({ counter: nextState.counter + 1 })); 
    };
	// counter状态变更 
	render() { 
        return ( 
            <Provider value={{ counter: this.state.counter, add: this.add }}> 
                {/* Consumer中内嵌函数，其参数是传递的数据，返回要渲染的组件 */} 
                {/* 把value展开传递给Child */} 
                <Consumer>{value => <Child {...value} />}</Consumer> 
                <Consumer>{value => <Child {...value} />}</Consumer> 
            </Provider>
        ); 
    } 
}
```



**如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个更好的解决方案**

#### redux

类似vuex，无明显关系的组件间通信

## ref

### DOM

```react
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个 ref 来存储 textInput 的 DOM 元素
    this.textInput = React.createRef();
    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // 直接使用原生 API 使 text 输入框获得焦点
    // 注意：我们通过 "current" 来访问 DOM 节点
    this.textInput.current.focus();
  }

  render() {
    // 告诉 React 我们想把 <input> ref 关联到构造器里创建的 `textInput` 上
    return (
      <div>
        <input
          type="text"
          ref={this.textInput} />
        <input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```

### Class

```react
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput();
  }

  render() {
    return (
      <CustomTextInput ref={this.textInput} />
    );
  }
}
```

默认情况下，**你不能在函数组件上使用 `ref` 属性**，因为它们没有实例

如果要在函数组件中使用 `ref`，你可以使用 [`forwardRef`](https://react.docschina.org/docs/forwarding-refs.html)（可与 [`useImperativeHandle`](https://react.docschina.org/docs/hooks-reference.html#useimperativehandle) 结合使用），或者可以将该组件转化为 class 组件。

**Ref 转发是一个可选特性，其允许某些组件接收 `ref`，并将其向下传递（换句话说，“转发”它）给子组件。**

```react
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

// 你可以直接获取 DOM button 的 ref：
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```

### 回调ref

```react
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);

    this.textInput = null;

    this.setTextInputRef = element => {
      this.textInput = element;
    };

    this.focusTextInput = () => {
      // 使用原生 DOM API 使 text 输入框获得焦点
      if (this.textInput) this.textInput.focus();
    };
  }

  componentDidMount() {
    // 组件挂载后，让文本框自动获得焦点
    this.focusTextInput();
  }

  render() {
    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React
    // 实例上（比如 this.textInput）
    return (
      <div>
        <input
          type="text"
          ref={this.setTextInputRef}
        />
        <input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```

## HOC高阶组件

范例：为展示组件添加获取数据能力

请注意，HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件*包装*在容器组件中来*组成*新组件。HOC 是纯函数，没有副作用。

不要试图在 HOC 中修改组件原型（或以其他方式改变它）。

```react
// Hoc.js 
import React from "react"; 
// Lesson保证功能单一，它不关心数据来源，只负责显示 
function Lesson(props) { 
    return ( <div> {props.stage} - {props.title} </div> ); 
}
// 模拟数据 
const lessons = [ 
    { stage: "React", title: "核心API" }, 
    { stage: "React", title: "组件化1" }, 
    { stage: "React", title: "组件化2" } 
];
// 高阶组件withContent负责包装传入组件Comp 
// 包装后组件能够根据传入索引获取课程数据，真实案例中可以通过api查询得到 
const withContent = Comp => props => { 
    const content = lessons[props.idx]; 
    // {...props}将属性展开传递下去 
    return <Comp {...content} />; 
};
// LessonWithContent是包装后的组件 
const LessonWithContent = withContent(Lesson); 
export default function HocTest() { 
    // HocTest渲染三个LessonWithContent组件 
    return ( 
        <div> {[0,0,0].map((item, idx) => ( <LessonWithContent idx={idx} key={idx} /> ))} </div> 
    ); 
}
```

范例：改造前面案例使上下文使用更优雅

```react
// withConsumer是高阶组件工厂，它能根据配置返回一个高阶组件 
function withConsumer(Consumer) { 
    return Comp => props => { 
        return <Consumer>{value => <Comp {...value} {...props} />}</Consumer>; 
    }; 
}
// Child显示计数器，并能修改它，多个Child之间需要共享数据 
// 新的Child是通过withConsumer(Consumer)返回的高阶组件包装所得 
const Child = withConsumer(Consumer)(function (props) { 
    return <div onClick={() => props.add()} title={props.name}>{props.counter}</div>; 
}); 
export default class ContextTest extends React.Component { 
    render() { 
        return ( 
        <Provider value={{ counter: this.state.counter, add: this.add }}> 
            {/* 改造过的Child可以自动从Consumer获取值，直接用就好了 */} 
            <Child name="foo"/> 
            <Child name="bar"/>
        </Provider> 
    	); 
    } 
}
```

### 链式调用

```react
// 高阶组件withLog负责包装传入组件Comp 
// 包装后组件在挂载时可以输出日志记录 
const withLog = Comp => { 
    // 返回组件需要生命周期，因此声明为class组件 
    return class extends React.Component { 
        render() { 
            return <Comp {...this.props} />; 
        }
        componentDidMount() { 
            console.log("didMount", this.props); 
        } 
    }; 
};
// LessonWithContent是包装后的组件 
const LessonWithContent = withLog(withContent(Lesson));
```

### 装饰器写法 

CRA项目中默认不支持js代码使用装饰器语法，可修改后缀名为tsx则可以直接支持 

```react
// 装饰器只能用在class上 
// 执行顺序从下往上 
@withLog 
@withContent 
class Lesson2 extends React.Component { 
    render() { 
        return ( <div> {this.props.stage} - {this.props.title} </div> ); 
    } 
}
export default function HocTest() { 
    // 这里使用Lesson2 
    return ( 
        <div> {[0, 0, 0].map((item, idx) => ( 
                <Lesson2 idx={idx} key={idx} /> 
            ))} 
        </div> 
    ); 
}
```

注意修改App.js中引入部分，添加一个后缀名 

要求cra版本高于2.1.0 

## Render Props

我们可以提供一个带有函数 prop 的 `<Mouse>` 组件，它能够动态决定什么需要渲染的，而不是将 `<Cat>` 硬编码到 `<Mouse>` 组件里，并有效地改变它的渲染结果。

```react
class Cat extends React.Component {
  render() {
    const mouse = this.props.mouse;
    return (
      <img src="/cat.jpg" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} />
    );
  }
}

class Mouse extends React.Component {
  constructor(props) {
    super(props);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove(event) {
    this.setState({
      x: event.clientX,
      y: event.clientY
    });
  }

  render() {
    return (
      <div style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}>

        {/*
          Instead of providing a static representation of what <Mouse> renders,
          use the `render` prop to dynamically determine what to render.
        */}
        {this.props.render(this.state)}
      </div>
    );
  }
}

class MouseTracker extends React.Component {
  render() {
    return (
      <div>
        <h1>移动鼠标!</h1>
        <Mouse render={mouse => (
          <Cat mouse={mouse} />
        )}/>
      </div>
    );
  }
}
```

## 组合

### 包含关系

```react
function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {/* 使用一个特殊的 children prop 来将他们的子组件传递到渲染结果 */}
      {props.children}
    </div>
  );
}

function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">
        Welcome
      </h1>
      <p className="Dialog-message">
        Thank you for visiting our spacecraft!
      </p>
    </FancyBorder>
  );
}
```

`<FancyBorder>` JSX 标签中的所有内容都会作为一个 `children` prop 传递给 `FancyBorder` 组件。因为 `FancyBorder` 将 `{props.children}` 渲染在一个 `<div>` 中，被传递的这些子组件最终都会出现在输出结果中。

少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 `children`，而是自行约定：将所需内容传入 props，并使用相应的 prop。

```react
function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">
        {props.left}
      </div>
      <div className="SplitPane-right">
        {props.right}
      </div>
    </div>
  );
}

function App() {
  return (
    <SplitPane
      left={
        <Contacts />
      }
      right={
        <Chat />
      } />
  );
}
```

也可以传递对象

```react
import React from "react"; 
// 获取相应部分内容展示在指定位置 
function Dialog(props) { 
    return ( 
        <div style={{ border: "1px solid blue" }}> 
            {props.children.default} 
            <div>{props.children.footer}</div> 
        </div> 
    ); 
}
export default function Composition() { 
    return ( 
        <div> {/* 传入显示内容 */} 
            <Dialog> {{
                    default: ( 
                        <>
                            <h1>组件复合</h1> 
                            <p>复合组件给与你足够的敏捷去定义自定义组件的外观和行为</p> 
                        </> 
                    ),
                    footer: <button onClick={() => alert("react确实好")}>确定</button> 
                }} 
            </Dialog> 
        </div> 
    ); 
}
```

如果传入的是函数，还可以实现作用域插槽的功能

```react
function Dialog(props) {
    // 备选消息 
    const messages = { 
        "foo": {title: 'foo', content: 'foo~'}, 
        "bar": {title: 'bar', content: 'bar~'}, 
    }
    // 执行函数获得要显示的内容 
    const {body, footer} = props.children(messages[props.msg]); 
    return ( 
        <div style={{ border: "1px solid blue" }}> 
            {/* 此处显示的内容是动态生成的 */} 
            {body} 
            <div>{footer}</div> 
        </div> 
    ); 
}
export default function Composition() { 
    return ( 
        <div> 
            {/* 执行显示消息的key */} 
            <Dialog msg="foo"> 
                {/* 修改为函数形式，根据传入值生成最终内容 */} 
                {({title, content}) => ({ 
                    body: ( 
                    <>
                        <h1>{title}</h1>
                        <p>{content}</p>
                    </> 
                	),
                    footer: 
                    <button onClick={() => alert("react确实好")}>确定</button>
                })} 
            </Dialog> 
        </div> 
    ); 
}
```

如果props.children是jsx，此时它是**不能修改**的 

范例：实现RadioGroup和Radio组件，可通过RadioGroup设置Radio的name 

```react
function RadioGroup(props) { 
    // 不可行, 
    // React.Children.forEach(props.children, child => { 
    // child.props.name = props.name; 
    // }); 
    return ( 
        <div> {React.Children.map(props.children, child => { 
                // 要修改虚拟dom 只能克隆它
                // 参数1是克隆对象
                // 参数2是设置的属性
                return React.cloneElement(child, { name: props.name });
                })} 
        </div> 
    ); 
}
// Radio传入value,name和children，注意区分 
function Radio({ children, ...rest }) { 
    return ( <label> <input type="radio" {...rest} /> {children} </label> ); 
}
export default function Composition() { 
    return ( 
        <div> 
            {/* 执行显示消息的key */} 
            <RadioGroup name="mvvm"> 
                <Radio value="vue">vue</Radio> 
                <Radio value="react">react</Radio> 
                <Radio value="ng">angular</Radio> 
            </RadioGroup> 
        </div> 
    ); 
}
```

#### React.Children

`React.Children` 提供了用于处理 `this.props.children` 不透明数据结构的实用方法。

**React.Children.map**

```
React.Children.map(children, function[(thisArg)])
```

在 `children` 里的每个直接子节点上调用一个函数，并将 `this` 设置为 `thisArg`。如果 `children` 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 `null` 或是 `undefined`，则此方法将返回 `null` 或是 `undefined`，而不会返回数组。

### 特例关系

有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 `WelcomeDialog` 可以说是 `Dialog` 的特殊实例。

在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件，即对一般组件进行包装

## 组件的生命周期

概念：在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件，统称为组件的生命周期；

### 16.0之前的生命周期

![react16之前的生命周期](E:\Jennifer\other\notes\media\react16之前的生命周期.png)

**第一个是组件初始化(initialization)阶段** 

也就是以下代码中类的构造方法( constructor() ),Test类继承了react Component这个基类，也就继承这个react的 基类，才能有render(),生命周期等方法可以使用，这也说明为什么 函数组件不能使用这些方法 的原因。 

super(props) 用来调用基类的构造方法( constructor() ), 也将父组件的props注入给子组件。 而 constructor() 用来做一些组件的初始化工作，如定义this.state的初始内 容。

```react
import React, { Component } from 'react'; 
class Test extends Component { 
    constructor(props) { super(props); } 
}
```

**第二个是组件的挂载(Mounting)阶段**

此阶段分为componentWillMount，render，componentDidMount三个时期。

- componentWillMount: 

在组件挂载到DOM前调用，且只会被**调用一次**，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。 

- render: 

根据组件的props和state（两者的**重传递和重赋值**，无论值是否有变化，都可以引起组件重新render） ，return 一个React元素，不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面 DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用）， 不能在里面执行this.setState，会有改变组件状态的副作用。 

- componentDidMount:

组件挂载到DOM后调用，且只会被**调用一次**

**第三个是组件的更新(update)阶段**

注意：setState引起的state更新或父组件重新render引起的props更 新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。

**造成组件更新有两类（三种）情况：**

1. 父组件重新render

父组件重新render引起子组件重新render的情况有两种

a. 每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通 过shouldComponentUpdate方法优化。 

b.在componentWillReceiveProps方法中，将props转换成自己的state

```react
class Child extends Component { 
    constructor(props) { 
        super(props); 
        this.state = { someThings: props.someThings }; 
    }
    componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法 
        this.setState({someThings: nextProps.someThings}); 
    }
    render() { 
        return <div>{this.state.someThings}</div> 
    } 
}
```

根据官网的描述 

> 在该函数(componentWillReceiveProps)中调用 this.setState() 将不会引起第二次渲染。 

是因为componentWillReceiveProps中判断props是否变化了，若变化了，this.setState将引起state变化，从而引 起render，此时就没必要再做第二次因重传props引起的render了，不然重复做一样的渲染了。 

2. 组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化。

**此阶段分为componentWillReceiveProps，shouldComponentUpdate， componentWillUpdate，render，componentDidUpdate**

- componentWillReceiveProps(nextProps) 

此方法只调用于**props引起的组件更新**过程中，参数nextProps是父组件传给当前组件的新props。但父组件render 方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传 的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState触发当前组件的重新render 

- shouldComponentUpdate(nextProps, nextState) 

此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新 过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。 

ps：这边也可以看出，就算componentWillReceiveProps()中执行了this.setState，更新了state，但在render前 （如shouldComponentUpdate，componentWillUpdate），this.state依然指向更新前的state，不然nextState 及当前组件的this.state的对比就一直是true了。 

- componentWillUpdate(nextProps, nextState) 

此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。 

- render 

- componentDidUpdate(prevProps, prevState)

此方法在组件更新后被调用，可以**操作组件更新的DOM**，prevProps和prevState这两个参数指的是组件更新前的 props和state 

**卸载阶段**

- componentWillUnmount 

此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清除componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。

**总结**

组件生命周期的执行顺序：

- Mounting：
  - constructor()
  - componentWillMount()
  - render()
  - componentDidMount()
- Updating：
  - componentWillReceiveProps(nextProps)
  - shouldComponentUpdate(nextProps, nextState)
  - componentWillUpdate(nextProps, nextState)
  - render()
  - componentDidUpdate(prevProps, prevState)
- Unmounting：
  - componentWillUnmount()

**React v16.4** **的生命周期**

![react16.4生命周期](E:\Jennifer\other\notes\media\react16.4生命周期.png)

### 16.4的生命周期

原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering， 在render函数之前的所有函数，都有可能被执行多次。

如果开发者**开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被 无谓地多次调用**。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果 也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结 果），这样的IO操作放在componentDidMount里更合适。 

禁止不能用比劝导开发者不要这样用的效果更好，所以**除了shouldComponentUpdate，其他在render函数之前的 所有函数（componentWillMount，componentWillReceiveProps，componentWillUpdate）都被 getDerivedStateFromProps替代。** 

也就是用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，**就是强制开发者在 render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state** 

React v16.0刚推出的时候，是增加了一个componentDidCatch生命周期函数，这只是一个增量式修改，完全不影 响原有生命周期函数；但是，到了React v16.3，大改动来了，引入了两个新的生命周期函数。 

**getDerivedStateFromProps** 

**static getDerivedStateFromProps(props, state)** 在组件创建时和更新时的render方法之前调用，它应该返回 一个对象来更新状态，或者返回null来不更新任何内容。 

getDerivedStateFromProps 本来（React v16.3中）是只在创建和更新（由父组件引发部分），也就是不是由父 组件引发，那么getDerivedStateFromProps也不会被调用，如自身setState引发或者forceUpdate引发。 在React v16.4中改正了这一点，让getDerivedStateFromProps无论是Mounting还是 Updating，也无论是因为什么引起的Updating，全部都会被调用，具体可看React v16.4 的生命周期图。 

**getSnapshotBeforeUpdate** 

**getSnapshotBeforeUpdate()** 被调用于render之后，**可以读取但无法使用DOM**的时候。它使您的组件可以在可 能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给 componentDidUpdate（）。 

[React Native 中组件的生命周期](http://www.race604.com/react-native-component-lifecycle/)


![React中组件的生命周期](E:/Jennifer/other/notes/react/images/LifeCycle.png)

### Counter计数器的小案例

封装组件

1. 给组件设置默认启动属性：`static defaultProps = {}`

2. 给属性进行类型校验，需要先运行`cnpm i prop-types --save`，v.15之后单独抽离了这个包

   ```jsx
   import React from 'react'
   import PropTypes from 'prop-types'
   class Counter{
       constructor(props) extends React.Componet{
           super(props)
           this.state = {}
       }
   	static defaultProps = {initCount: 0}
   	// 创建一个propTypes对象，可以给外界传递的属性进行类型校验
   	static propTypes = {initCount: PropTypes.number}
   	render() {
       	return <div>
           </div>
   	}
   }
   ```

### 组件初始化时生命周期事件总结

1. componentWillMount：可以获取props，state和已经定义的函数，相当于Vue的created函数

2. render：创建虚拟DOM

3. componentDidMount：可以获取页面的DOM元素，想要操作DOM最早在这个函数

4. shouldComponentUpdate：必须返回布尔，返回false时虚拟DOM和页面都不会更新，可能会造成画面和组件状态的不一致

   直接通过`this.state`获取的state值是上一次的值，要获取最新的值，要通过参数列表的`nextProps或nextState`获取

5. componentWillUpdate：虚拟DOM和页面上的DOM都是旧的

6. render：创建阶段和运行阶段都有，DOM还没渲染之前可以利用短路运算防止报错

7. 注意：在render函数中，不能调用`setState()`方法

8. componentDidUpdate：DOM都是最新的

9. componentWillReceiveProp：第一次渲染不会触发，`this.props`获取到的是上一次的值，要获取最新的值，要通过参数列表的`nextProps或nextState`获取

## 绑定this并传参的三种方式

1. 在事件中绑定this并传参：

```jsx
// bind可以改变前面函数的this指向，和call/apply不同，call/apply改变this后会执行前面的函数
// bind的第一个参数改变了this指向，后面就是要传递的参数
<input type="button" value="在事件中绑定this并传参" onClick={this.handleMsg1.bind(this, '🍕', '🍟')} />

// 在事件中绑定this并传参
handleMsg1(arg1, arg2) {
    console.log(this);
    // 此时this是个null
    this.setState({
        msg: '在事件中绑定this并传参：' + arg1 + arg2
    });
}
```

1. 在构造函数中绑定this并传参:

```jsx
// 修改构造函数中的代码：
// bind的返回值是改变this之后的函数的引用
// bind不会改变原函数的this指向，要使用改变之后的函数要重新接收
this.handleMsg2 = this.handleMsg2.bind(this, '🚗', '🚚');

<input type="button" value="在构造函数中绑定this并传参" onClick={this.handleMsg2} />

// 在构造函数中绑定this并传参
handleMsg2(arg1, arg2) {
    this.setState({
        msg: '在构造函数中绑定this并传参：' + arg1 + arg2
    });
}
```

1. 用箭头函数绑定this并传参：

```jsx
// 用箭头函数绑定this并传参
<input type="button" value="用箭头函数绑定this并传参" onClick={() => { this.handleMsg3('👩', '👰') }} />

handleMsg3(arg1, arg2) {
    this.setState({
        msg: '用箭头函数绑定this并传参：' + arg1 + arg2
    });
}
```

## Hooks

*Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性

### 状态钩子 State Hook

```react
import React, { useState } from "react";
export default function HooksTest() { 
    // useState(initialState)，接收初始状态，返回一个由状态和其更新函数组成的数组
    const [fruits, setFruits] = useState(["香蕉", "西瓜"]); 
    return ( 
        <div>
            <p>{fruit === "" ? "请选择喜爱的水果：" : `您的选择是：${fruit}`}</p> 
            {/*添加列表组件*/} 
            <FruitList fruits={fruits} onSetFruit={setFruit}/> 
            {/*添加水果组件*/} 
            <FruitAdd onAddFruit={pname => setFruits([...fruits, pname])} /> 
        </div> 
    ); 
}

// 声明列表组件 
function FruitList({fruits, onSetFruit}) { 
    return ( 
        <ul>{fruits.map(f => ( 
                <li key={f} onClick={() => onSetFruit(f)}> {f} </li>
            ))} 
        </ul> ); 
}

// 声明输入组件 
function FruitAdd(props) { 
    // 输入内容状态及设置内容状态的方法 
    const [pname, setPname] = useState(""); 
    // 键盘事件处理 
    const onAddFruit = e => { 
        if (e.key === "Enter") { 
        	props.onAddFruit(pname); setPname(""); 
        }
    };
    return ( 
        <div> 
            <input type="text" value={pname} onChange={e => setPname(e.target.value)} onKeyDown={onAddFruit} /> 
        </div> ); 
}
```

### 副作用钩子 Effffect Hook

useEffect 给函数组件增加了执行副作用操作的能力。 

副作用（Side Effffect）是指一个 function 做了和本身运算返回值无关的事，比如：修改了全局变量、修改了传入的参数、甚至是 console.log()，所以 ajax 操作，修改 dom 都是算作副作用。

```react
// 异步数据获取，更新HooksTest.js
import { useEffect } from "react"; 
useEffect(()=>{ 
    setTimeout(() => { setFruits(['香蕉','西瓜']) }, 1000); 
},[])
// 设置空数组意为没有依赖，则副作用操作仅执行一次
// 如果副作用操作对某状态有依赖，务必添加依赖选项
// useEffect(() => { document.title = fruit; }, [fruit]);

// 清除工作：有一些副作用是需要清除的，清除工作非常重要的，可以防止引起内存泄露
useEffect(() => { 
    const timer = setInterval(() => { console.log('msg'); }, 1000); 
    return function(){ 
        clearInterval(timer); 
    } 
}, []);
```

### useReducer

[`useState`](https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate) 的替代方案。它接收一个形如 `(state, action) => newState` 的 reducer，并返回当前的 state 以及与其配套的 `dispatch` 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）

在某些场景下，`useReducer` 会比 `useState` 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 `useReducer` 还能给那些会触发深更新的组件做性能优化，因为[你可以向子组件传递 `dispatch` 而不是回调函数](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down) 。

常用于组件有复杂状态逻辑时，类似于redux中reducer概念。

```react
// 商品列表状态维护
import { useReducer } from "react"; 
// 添加fruit状态维护fruitReducer 
function fruitReducer(state, action) { 
    switch (action.type) { 
        case "init": return action.payload; 
        case "add": return [...state, action.payload]; 
        default: return state; 
    } 
}
export default function HooksTest() { 
    // 组件内的状态不需要了 
    // const [fruits, setFruits] = useState([]); 
    // useReducer(reducer，initState) 
    const [fruits, dispatch] = useReducer(fruitReducer, []); 
    useEffect(() => { 
        setTimeout(() => { 
            // setFruits(["香蕉", "西瓜"]); 
            // 变更状态，派发动作即可 
            dispatch({ type: "init", payload: ["香蕉", "西瓜"] }); 
        }, 1000); 
    }, []); 
    return ( 
        <div> 
            {/*此处修改为派发动作*/} 
            <FruitAdd onAddFruit={pname => dispatch({type: 'add', payload: pname})} /> 
        </div>
    );
}
```

计数器案例：

```react
const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```

### useContext

useContext用于在快速在函数组件中导入上下文。

```react
import React, { useContext } from "react"; 
// 创建上下文 
const Context = React.createContext(); 
export default function HooksTest() { 
    // ... 
    return ( 
        {/* 提供上下文的值 */} 
        <Context.Provider value={{fruits,dispatch}}> <div> 
            {/* 这里不再需要给FruitAdd传递状态mutation函数，实现了解耦 */} 
            <FruitAdd /> </div>
        </Context.Provider> 
    ); 
}
function FruitAdd(props) { 
    // 使用useContext获取上下文 
    const {dispatch} = useContext(Context) 
    const onAddFruit = e => { 
        if (e.key === "Enter") { 
            // 直接派发动作修改状态 
            dispatch({ type: "add", payload: pname }) 
            setPname(""); 
        } 
    };
    // ... 
}
```

# 