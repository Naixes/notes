# 前端基础

## html

1. html布局元素分类有哪些？应用场景都是什么？

有行内元素，块状元素，行内块状元素

行内元素从左向右显示，宽高由内容决定不能直接控制，只能嵌套行内元素，常见的有span a textarea，display: inline

块状元素独占一行，宽度默认父元素宽度，高度默认本身内容高度，常见的div h1-6 ul li p form，display: block

行内块状元素，集合了两种特性，不自动换行并且可以设置宽高，display: inline-block



2. b和strong区别

效果一样，目的不一样，b注重样式，strong表示强调，即样式标签和语义化标签的区别

语义化标签优势在于便于理解，结构明确，利于seo，一个重要场景就是无障碍阅读



3. 减少dom数量的办法？怎么优化大量的dom

不使用无意义标签，使用伪元素代替，比如阴影，清除浮动

按需加载

结构合理，语义化标签

优化：

缓存dom对象，比如在循环遍历之前先获取到主节点

合并操作：使用文档片段，`document.createDocumentFragment()`操作文档片段不会影响真实dom，做完所有操作后一次性更新到dom；进行复杂的dom操作时，先删除或者复制元素，操作完成后再更新

使用innerHtml代替频繁的appendChild

虚拟dom+diff



4. a标签禁用默认事件后怎样实现跳转

使用location.href = href



5. SEO

seo优化就是提高网站在搜索引擎的权重，重点就是提高搜索引擎对网站的理解

最基础的方法就是title，description，keywords，语义化标签，图片的alt，唯一的h1，页面扁平，flash/图片/视频/iframe/异步加载抓取不到，优先加载重要内容，提高速度，友情链接

- 网站结构布局：

控制首页链接数量，扁平化跳转层次，导航尽量文字，

头部包括logo主导航用户信息，使用面包屑导航，右相关连接，底部版权信息和友情链接，分页使用页码

优先加载重要内容

控制页面大小，减少请求，提高速度

- 代码优化：

合理的title，description，keywords

语义化标签

a，内部链接加title，外部链接加el="nofollow"，只能抓取href，不要带参数

唯一的h1

图片添加alt

表格标题使用caption

不会执行js，重要内容不要使用js输出

会过滤display: none，只能抓取get请求

减少iframe

使用robots.txt



6. meta标签

提供页面的元信息，属性：charset，content，http-equiv，name

http-equiv，http头部某些作用，可以改变服务器和用户代理行为

content与http-equiv，name配合

name定义元数据不和charset，http-equiv共存

常用：声明字符集，viewport，优先使用的浏览器版本



7. async和defer

都是为了脚本执行时不影响页面构造，会延迟到页面解析后执行，相当于告诉浏览器立即下载延迟执行，对内联脚本不起作用，脚本中不能调用document.write

defer规范要求按照出现顺序执行并且先于DOMContentLoaded执行，实际上并不一定，所以最好只包含一个延迟脚本，async不保证执行先后顺序

async是html5定义，浏览器支持不同，同时存在时只触发async

## css

## js

# 浏览器

## http

1. 浏览器工作过程

简单版：

输入网址回车，先做一些准备工作，检查能不能访问互联网--通过DNS服务器解析域名得到ip地址？-- 建立TCP连接 -- 发送http请求，用到了路由技术找到机房--通过反向代理发送到对应服务器，服务器处理请求--原路返回html响应 -- 解析数据处理html页面--请求其他资源--绘制界面

http工作过程：

一次http操作是一次事务，首先客户机和服务器要建立一个tcp连接，连接建立后客户机开始给服务端发送请求，请求的格式为请求行，请求头和请求体，请求行包括请求方法名、统一资源标识符(URI)、协议版本号，请求头：头字段，MIME信息，包括请求修饰符、客户机信息等，服务器返回响应信息，格式为响应行，响应头和响应体，响应行包括信息的协议版本号、响应状态代码和文本描述，响应头：头字段，MIME信息，包括服务器信息，客户端收到响应展示页面，最后断开连接

以上是短连接请求过程，长连接包括多次请求和响应

详细版：

浏览器标准处理流程，从请求发出到响应回来渲染到浏览器navigation timing，api用来分析性能，通过每个过程上面的标签来计时

浏览器处理

1提示卸载，卸载上一页，可以看作初始化，navigationStart

2本地重定向（查看本地缓存），没有跳过，redirectStart/redirectEnd，同时并发执行卸载上一页unloadStart/unloadEnd，可能出现性能瓶颈的位置，unload事件中执行的事情

3有缓存时获取缓存，读文件，属于IO操作，也是瓶颈位置，fetchStart

网络操作

4DNS，获取ip，标签是domainLookupStart/domainLookupEnd，也是瓶颈位置，底层传输层协议UDP，有不同的镜像服务器有的远有的近，跨网的时候会慢，还有带宽和地理上的影响，通过CDN优化，就近原则

5TCP，建立连接三次握手，connectStart/connectEnd，瓶颈位置，受到网络影响

6请求，发送请求，requestStart，请求结束没办法界定，因为navigation timing跑在客户端，所以这部分包含了服务器响应的时间

7响应，收到响应，responseStart/responseEnd，这里长可能是数据过大或网络链路不好，可以开启压缩或者架设镜像服务器

浏览器

8processing，流转成文本，转成dom，处理dom，domLoading转化/domInteractive处理/domContentLoaded加载/domComplete完成

9触发onLoad事件，loadEventStart/loadEventEnd



2. DNS解析过程

域名很多为了加快解析，分到了多个服务器，不同等级的域名归不同的服务器管（分治），分根服务器，TLD服务器，名称服务器（负责一级域名以后的），客户端路由器收到DNS解析请求以后会把域名发到DNS服务器（路由器内置，经过路由器中转到DNS服务器），DNS服务器有一个缓存，先查看有没有缓存，没有的话先从根服务器处理顶级域名（全球有13个），查到以给定顶级域名结尾的一级域名归哪个TLD服务器，返回这个服务器ip给DNS服务器，DNS再给TLD服务器发送第二个请求，返回名称服务器ip，DNS再发送第三次请求，名称服务器会找到最终的ip返回。由于通信较多所以没有用TCP

过程中的优化包括，DNS的缓存，还有大数据库的镜像，减少通讯，阿里云等买到域名设置好了ip之后会有一个提示，十分钟之内同步，就是将解析记录主动同步到镜像



3. CDN

解决问题：分散所有客户端请求同一个服务器的数据请求压力，使用镜像服务器，依赖DNS使用就近原则解析到最近的镜像，比如每个区域解析到的ip不是同一个，取决于网络环境



2. HTTP协议

超文本传输协议，为了统一计算机的通信方式而产生的，规定了客户机和服务机之间请求和响应的方法

请求方法

常用请求头响应头

状态码

早一点的0.9版本已经有了最基本的语义和规则，1.0基本完整稳定，1.1成熟，增加了**长连接**（TCP），2改变了底层机制，TCP的实现层面 ，很多网站已经迁移到了2，看协议头可以看出1和2，带冒号的伪头，重新设计了协议封装

**HTTP1.1**

- keep-alive，长连接

在一定时间内，同一个域名多次请求数据，只建立一次HTTP连接，其他请求复用连接通道，提高效率，一定时间是可以配置的，1.1还存在效率问题，文件的串行传输和连接数限制，HTTP2的多路复用对此惊醒了优化

**HTTP2**

语义没有改变，改变了协议的实现

- 改变了数据的封装格式，之前是文本不稳定解析容易出错，改成了二进制形式更紧凑，解析更高效

- 引入分帧层，无法兼容，产生了伪头

将消息分成了更小的消息和帧，比如之前的请求行请求头请求体之间没有明显的区分，现在分成两帧头帧和数据帧，界限明显用了二进制的分割符，头有专门描述头的长度的字段，来计算偏移量。更加的严密了

伪头字段，没有请求行请求头都封装到头帧里了，但是还得是键值对模式让浏览器进行处理所以使用伪头代替了请求行和请求头，本质是因为数据的封装格式变化了

- 压缩报头，之前只是压缩报文体，不压缩头

- 多路复用，一个TCP连接可以并行传输多个文件，之前是串行

之前可以并发发起多个请求，每个请求都需要建立连接，服务器压力变大，需要维护每个连接，HTTP2的多路复用对同一个域名下的所有请求都是基于流的，所以只需要一个连接，可以并发传输多个数据，解决了1.1并发连接数的限制，Apache最大连接数是300。1.1要想在一个连接发送多个数据是串行的，会产生队首阻塞，多路复用会把文件切成小块轮流发送，在另一端重新组装，看起来像是并行传输，也会产生阻塞但是只阻塞了当前文件，其他文件不受影响，有一定的优化。阻塞是由于TCP的特性产生的，在TCP层面是无法解决的。

阻塞的主要原因是基于链路，两层链路TCP和TLS，加密以文件为单位，解密需要等完整的文件传输过来，所以会有当前文件的阻塞问题

HTTP3完全解决了阻塞

- 服务器主动推送，减少请求延迟

比websocket轻量，不能完全取代websocket，只是在推送方面取代，websocket是双向的，http是基于请求和响应，相当于一次请求多次响应

- 默认使用加密

**HTTP3**

解决了队首阻塞，发包时没有顺序，有一个编号，以包为单位，所有收到以后组装时发现有丢包要求重发，加解密也是以包为单位，不存在阻塞问题

基于QUIC，QUIC基于UDP，为了解决性能问题，同时也很严密，对数据包进行加密，不是链路加密

跨多层实现属于会话层和安全层

- 减少了握手的延迟，一次握手（首次通信，探查服务器在不在）或不握手（1TTR或0TTR），切换网络也不需要重新握手，因为没有链路
- 更灵活的多路复用，没有链路，没有阻塞
- 连接迁移，切换网络时连接不会断开，适用于移动端



3. 反向代理

正向代理，类似代购，反向代理，类似门房

nginx，c语言写的

用途：加密（配置HTTPS）和SSL加速，负载均衡（CDN），缓存静态文件，压缩，减速上传（有选择的丢包，延迟响应），安全，相当于一层堡垒给解决争取时间，外网发布（整合各种服务到同一个端口）



3. TLS握手

主要是协商加密算法，交换证书，交换密钥，切换到加密

TCP握手

客户端发送支持的协议版本，加密算法和压缩方法

服务端确定协议版本，加密算法和压缩方法，返回给客户端

服务端发送证书

服务端通知协商结束

客户端通过服务端公钥加密公钥和密钥种子发送给服务端

双方计算密钥

客户端通知切换加密

客户端准备完成

服务端通知切换加密

服务端准备完成

加密通信

通信完成后切断SSL

TCP挥手



3. TCP和UDP



2. HTTP缓存

分为强缓存和协商缓存，都是通过http header实现

强缓存优先于协商缓存

第一次请求没有缓存，服务器设置cache-control和expires或者etag和last-modified并返回资源

再次请求时，先检查强制缓存是否过期未过期不会发起请求直接从缓存中获取，状态为200

强缓存过期后进行协商缓存，依次发送文件上的etag/last-modified，头字段if-none-match/if-modified-since，服务器判断与自己维护的内容md5/时间戳是否相同，相同时使用浏览器缓存时返回304，否则说明资源变化返回最新数据状态200，然后重新进行缓存协商



3. TCP握手/挥手

**三次握手**

不包含数据

客户端发起连接请求，SYN指令，顺序号seq=x

服务端响应握手包发送SYN指令，顺序号seq=y，应答号ACK=x+1，客户端收到应答号，客户端能确认服务器能收到自己的数据，达到半连接，半连接不能保证服务器能收到客户端的数据

客户端发送应答号ACK=y+1，服务器收到应答号，服务端能确认客户端能收到自己的数据，达到全连接

三次交互保证对方可以正确得接收自己的数据

两次握手（半连接）的问题：如果客户端不断发起连接请求，服务端需要维护的连接数据越来越多，由于服务器还需要遍历数组，维护连接超时，数据过多时服务器会拒绝服务，这是拒绝服务攻击的一种，半连接攻击，缩短超时间可以缓解但是不能解决问题解决：防火墙，堆硬件

**四次挥手**

一般是客户端发起断开

收到断开请求后马上返回，然后做收尾工作，最后再发送断开请求，所以响应和FIN请求分成两次发送

客户端发送FIN指令，顺序号seq=x+2，应答号ACK=y+1

服务器立刻响应，应答号ACK=x+3

服务器做完收尾工作后发送FIN指令，顺序号seq=y+1

客户端收到后响应，应答号ACK=y+2，至此连接断开



`======其他相关题目======`

1. 图片资源为什么放在不同的域名下面

浏览器对并发请求的数目限制是针对域名的，即针对同一域名（包括二级域名）在同一时间支持的并发请求数量的限制。如果请求数目超出限制，则会阻塞。因此，网站中对一些静态资源，使用不同的一级域名，可以提升浏览器并行请求的数目，加速界面资源的获取速度。



2. 浏览器与服务器建立一个TCP连接后，是否会在完成一个http请求后断开？什么条件下会断开？

`HTTP/1.1`将`Connection`写入了标准，默认值为`keep-alive`。默认情况下建立的TCP连接不会断开，只有在请求头中设置`Connection: close`才会在请求后关闭TCP连接。



3. 一个TCP连接可以同时发送几个HTTP请求？

`HTTP/1.1`中，单个TCP连接，在同一时间只能处理一个http请求，虽然存在Pipelining技术支持多个请求同时发送，但由于实践中存在很多问题无法解决，所以浏览器默认是关闭，所以可以认为是不支持同时多个请求。

`HTTP2`提供了多路传输功能，多个http请求，可以同时在同一个TCP连接中进行传输。



4. 浏览器http请求的并发性是如何体现的？并发请求的数量有没有限制？

页面资源请求时，浏览器会同时和服务器建立多个TCP连接，在同一个TCP连接上顺序处理多个HTTP请求。所以浏览器的并发性就体现在可以建立多个TCP连接，来支持多个http同时请求。

Chrome浏览器最多允许对同一个域名Host建立6个TCP连接，不同的浏览器有所区别。

如果图片都是HTTPS的连接，并且在同一域名下，浏览器会先和服务器协商使用`HTTP2`的`Multiplexing`功能进行多路传输，不过未必所有的挂在这个域名下的资源都会使用同一个TCP连接。如果用不了HTTPS或者HTTP2（HTTP2是在HTTPS上实现的），那么浏览器会就在同一个host建立多个TCP连接，每一个TCP连接进行顺序请求资源。

## 渲染

1. 渲染原理

总体过程：

渲染部分通过html生成dom树，子资源加载，样式表计算，布局，绘制

主要参与模块：html解析器，css解析器，这两个在webcore中，js解释器（jscore或v8）

具体就是浏览器获取到html后，先进行字节流解码把字节数据转换为字符，包括一些字符的预处理，然后通过词法分析将字符串转化为标记同时生成dom树

遇到css时解析css，结构化css，不是树结构，是按照一定的数据结构生成css片段，在dom树上找到对应的节点，与css片段进行关联匹配，生成渲染树

如果遇到js，html解析器会暂停工作，将js给js解释器解析，js可以以桥接机制影响dom树和渲染树，js解析完成后html解析器继续工作

在渲染树的基础上加上布局规则一层一层得叠加生成布局渲染树，就是一个排版的过程

最后进行绘制，将数据显示到显示器上，需要调用显示后端，控件，字体，图形库视频解码库等，将视口里的内容映射到显示器上，就是计算像素点，通过显卡描到显示器上，一个图片就是一帧

以谷歌浏览器为例：

chrome是多进程浏览器，主进程就是浏览器进程，其他为子进程，比如插件进程，渲染由渲染进程负责，有多个一个域名是一个渲染进程，包括主线程和一些工作线程，js就跑在工作线程下，排版和栅格线程也在这个进程内运行

渲染过程：通过网络请求获取资源，html解析器开始解析根据html结构生成dom树，处理css片段生成数据结构，找到对应节点进行匹配关联生成渲染树，接下来进行排版就是计算每个节点的大小坐标和相对位置，基于根节点计算，生成排版树，然后进行一层一层合成生成层树，这些都在在主线程

一旦创建了层树确定了绘制顺序，就开始由GPU生成图，根据层树一个点一个点计算的，这里有一个优化，就是GPU把整个渲染任务进行分解，分成一个个小tile，通过GPU的各个核进行并行计算，计算完成之后将数据集中到显卡的显存里，显存将数据直接显示到显示器上，从屏幕左上角依次排列，速度很快具体取决于刷新率



2. 重绘重排

涉及到渲染的排版和绘制过程：重排 - 重绘 - 合成层

对dom元素进行分层，计算图形样式calculate style，对每个节点计算图形位置layout，将节点绘制填充到图层中paint，将图层作为纹理（CPU给GPU最小的一个bitmap）上传给GPU，GPU做一些旋转缩放什么的

GPU的合成层线程（composite layers）将符合的图层生成屏幕图像，具体工作：

主线程把绘制列表commit到合成线程

合成线程根据视口切成tile，比如256*256

栅格线程将小图块生成位图，也叫栅格化，保存到GPU

合成线程发送一个绘制图块的命令draw quad给浏览器进程

浏览器的viz组件接受命令，最终显示到屏幕上display

对GPU位图进行旋转缩放的时候，首次合成会有一个低分辨率的图，显示的时候会全部显示

可以独立成层的属性：根元素，position，transform，半透明，css滤镜，canvas，video，overflow

GPU可以加速的独立层：css3d，vidoe，webGL，transform，css滤镜，会跳过布局layout和绘制paint阶段（重绘重排）直接进入GPU合成层，比如淘宝轮播图使用translate的translate3d，也叫硬件加速

会造成重排的属性：读offset，scroll，client，width，盒子模型大小变化，浏览器会维护一个重绘重排队列等积累到一定数量或时间会进行批处理，但是遇到这些属性会放弃掉优化队列直接进行重排，box-sizing：border-box也是为了尽量减少外界对盒模型的影响

为了避免频繁的flash，可以将读写分别放在一起，不破坏浏览器的优化，或者使用requestAnimationFrame下一帧再写



# 性能优化

### 页面加载

spa，mpa，同构

### 传输过程优化

控制模块的拆分和合并，每个页面引用脚本不超过6个，因为网站最多并发请求是6个（受浏览器和http版本影响），要突破限制加CDN，在1.1时是有用的，还有一个好处是CDN可以去cookie，因为每次请求都会带cookie，cookie很长浪费资源，每个CDN不超过6个文件，超过了就新开域名，每个脚本压缩后32kb左右，webpack超过30kb才会提取为单独的文件，不够的话就需要懒加载或者做缓存

合理设置**浏览器缓存**，强缓存一般不会用在业务上，业务上一般会关闭强缓存no-cache使用etag，多用在库上基本不会修改，业务可以使用离线缓存前端就可以管理版本不需要服务端参与，有很多大公司直接将整个网站使用service worker离线缓存，确保用户体验

做**离线缓存**前端有一个localForage库对现有的离线缓存做了封装，百度地图就通过localStorage做了离线缓存js，大概过程就是启动js时有一个全局的md5的表，可以用webpack生成，写一个active.js负责加载js，当加载js时不直接请求js而是现在缓存中查看是否有缓存，缓存中存的是两个键值对，文件名：md5文件和md5文件名：js内容，本地没有缓存时才加载文件，使用eval或者addScript执行，然后再请求一次资源，将它注入缓存。如果缓存过期会进行清理再次注入。在中间加一层版本判断还可以进行版本控制，有5m的限制某些机型是2.5m，超过了也可以使用web SQL或indexedDB，但是这个是异步的，可以用在一些不重要的内容上比如广告位

使用basketjs+localforage做离线缓存库

service worker没有大小限制，可以缓存所有文件

**检测用户网速**响应不同的图片，`navigator.connection`或者多普勒测速法

多普勒测速法：请求三次0kb图片，一次10k，一次40k，t1为DNS+新建连接+1RTT往返，t2新建连接+1RTT往返，t31RTT往返（三次请求同一个资源时无论是HTTP2还是1.1都会开启多路复用）10k/（t4-t3）就是带宽

升级为**HTTP2**

### 渲染过程优化

js会等待css加载，因为js可以使用CSS类造成重排，使用css in js或者原生的css数组工厂函数代替字符串可以减少css请求

减少重排

常用性能优化指标：



# node