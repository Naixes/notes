# 前端基础

## html

1. html布局元素分类有哪些？应用场景都是什么？

有行内元素，块状元素，行内块状元素

行内元素从左向右显示，宽高由内容决定不能直接控制，只能嵌套行内元素，常见的有span a textarea，display: inline

块状元素独占一行，宽度默认父元素宽度，高度默认本身内容高度，常见的div h1-6 ul li p form，display: block

行内块状元素，集合了两种特性，不自动换行并且可以设置宽高，display: inline-block



2. b和strong区别

效果一样，目的不一样，b注重样式，strong表示强调，即样式标签和语义化标签的区别

语义化标签优势在于便于理解，结构明确，利于seo，一个重要场景就是无障碍阅读



3. 减少dom数量的办法？怎么优化大量的dom

不使用无意义标签，使用伪元素代替，比如阴影，清除浮动

按需加载

结构合理，语义化标签

优化：

缓存dom对象，比如在循环遍历之前先获取到主节点

合并操作：使用文档片段，`document.createDocumentFragment()`操作文档片段不会影响真实dom，做完所有操作后一次性更新到dom；进行复杂的dom操作时，先删除或者复制元素，操作完成后再更新

使用innerHtml代替频繁的appendChild

虚拟dom+diff



4. a标签禁用默认事件后怎样实现跳转

使用location.href = href



5. SEO

seo优化就是提高网站在搜索引擎的权重，重点就是提高搜索引擎对网站的理解

最基础的方法就是title，description，keywords，语义化标签，图片的alt，唯一的h1，页面扁平，flash/图片/视频/iframe/异步加载抓取不到，优先加载重要内容，提高速度，友情链接

- 网站结构布局：

控制首页链接数量，扁平化跳转层次，导航尽量文字，

头部包括logo主导航用户信息，使用面包屑导航，右相关连接，底部版权信息和友情链接，分页使用页码

优先加载重要内容

控制页面大小，减少请求，提高速度

- 代码优化：

合理的title，description，keywords

语义化标签

a，内部链接加title，外部链接加el="nofollow"，只能抓取href，不要带参数

唯一的h1

图片添加alt

表格标题使用caption

不会执行js，重要内容不要使用js输出

会过滤display: none，只能抓取get请求

减少iframe

使用robots.txt



6. meta标签

提供页面的元信息，属性：charset，content，http-equiv，name

http-equiv，http头部某些作用，可以改变服务器和用户代理行为

content与http-equiv，name配合

name定义元数据不和charset，http-equiv共存

常用：声明字符集，viewport，优先使用的浏览器版本



7. async和defer

都是为了脚本执行时不影响页面构造，会延迟到页面解析后执行，相当于告诉浏览器立即下载延迟执行，对内联脚本不起作用，脚本中不能调用document.write

defer规范要求按照出现顺序执行并且先于DOMContentLoaded执行，实际上并不一定，所以最好只包含一个延迟脚本，async不保证执行先后顺序

async是html5定义，浏览器支持不同，同时存在时只触发async

## css

## js

# 浏览器

## http

1. 浏览器工作过程

简单版：

输入网址回车，先做一些准备工作，检查能不能访问互联网--通过DNS服务器解析域名得到ip地址？-- 建立TCP连接 -- 发送http请求，用到了路由技术找到机房--通过反向代理发送到对应服务器，服务器处理请求--原路返回html响应 -- 解析数据处理html页面--请求其他资源--绘制界面

http工作过程：

一次http操作是一次事务，首先客户机和服务器要建立一个tcp连接，连接建立后客户机开始给服务端发送请求，请求的格式为请求行，请求头和请求体，请求行包括请求方法名、统一资源标识符(URI)、协议版本号，请求头：头字段，MIME信息，包括请求修饰符、客户机信息等，服务器返回响应信息，格式为响应行，响应头和响应体，响应行包括信息的协议版本号、响应状态代码和文本描述，响应头：头字段，MIME信息，包括服务器信息，客户端收到响应展示页面，最后断开连接

以上是短连接请求过程，长连接包括多次请求和响应

详细版：

浏览器标准处理流程，从请求发出到响应回来渲染到浏览器navigation timing，api用来分析性能，通过每个过程上面的标签来计时

浏览器处理

1提示卸载，卸载上一页，可以看作初始化，navigationStart

2本地重定向（查看本地缓存），没有跳过，redirectStart/redirectEnd，同时并发执行卸载上一页unloadStart/unloadEnd，可能出现性能瓶颈的位置，unload事件中执行的事情

3有缓存时获取缓存，读文件，属于IO操作，也是瓶颈位置，fetchStart

网络操作

4DNS，获取ip，标签是domainLookupStart/domainLookupEnd，也是瓶颈位置，底层传输层协议UDP，有不同的镜像服务器有的远有的近，跨网的时候会慢，还有带宽和地理上的影响，通过CDN优化，就近原则

5TCP，建立连接三次握手，connectStart/connectEnd，瓶颈位置，受到网络影响

6请求，发送请求，requestStart，请求结束没办法界定，因为navigation timing跑在客户端，所以这部分包含了服务器响应的时间

7响应，收到响应，responseStart/responseEnd，这里长可能是数据过大或网络链路不好，可以开启压缩或者架设镜像服务器

浏览器

8processing，流转成文本，转成dom，处理dom，domLoading转化/domInteractive处理/domContentLoaded加载/domComplete完成

9触发onLoad事件，loadEventStart/loadEventEnd



2. DNS解析过程

域名很多为了加快解析，分到了多个服务器，不同等级的域名归不同的服务器管（分治），分根服务器，TLD服务器，名称服务器（负责一级域名以后的），客户端路由器收到DNS解析请求以后会把域名发到DNS服务器（路由器内置，经过路由器中转到DNS服务器），DNS服务器有一个缓存，先查看有没有缓存，没有的话先从根服务器处理顶级域名（全球有13个），查到以给定顶级域名结尾的一级域名归哪个TLD服务器，返回这个服务器ip给DNS服务器，DNS再给TLD服务器发送第二个请求，返回名称服务器ip，DNS再发送第三次请求，名称服务器会找到最终的ip返回。由于通信较多所以没有用TCP

过程中的优化包括，DNS的缓存，还有大数据库的镜像，减少通讯，阿里云等买到域名设置好了ip之后会有一个提示，十分钟之内同步，就是将解析记录主动同步到镜像



3. CDN

解决问题：分散所有客户端请求同一个服务器的数据请求压力，使用镜像服务器，依赖DNS使用就近原则解析到最近的镜像，比如每个区域解析到的ip不是同一个，取决于网络环境



2. HTTP协议

超文本传输协议，为了统一计算机的通信方式而产生的，规定了客户机和服务机之间请求和响应的方法

请求方法

常用请求头响应头

状态码

早一点的0.9版本已经有了最基本的语义和规则，1.0基本完整稳定，1.1成熟，增加了**长连接**？？（TCP），2改变了底层机制，TCP的实现层面 ，很多网站已经迁移到了2，看协议头可以看出1和2，带冒号的伪头，重新设计了协议封装

**HTTP2**

语义没有改变，改变了协议的实现

- 改变了数据的封装格式，之前是文本不稳定解析容易出错，改成了二进制形式更紧凑，解析更高效

- 引入分帧层，无法兼容，产生了伪头

将消息分成了更小的消息和帧，比如之前的请求行请求头请求体之间没有明显的区分，现在分成两帧头帧和数据帧，界限明显用了二进制的分割符，头有专门描述头的长度的字段，来计算偏移量。更加的严密了

伪头字段，没有请求行请求头都封装到头帧里了，但是还得是键值对模式让浏览器进行处理所以使用伪头代替了请求行和请求头，本质是因为数据的封装格式变化了

- 压缩报头，之前只是压缩报文体，不压缩头

- 多路复用，一个TCP连接可以并行传输多个文件，之前是串行

之前可以并发发起多个请求，每个请求都需要建立连接，服务器压力变大，需要维护每个连接，多路复用只需要一个连接，可以并发传输多个数据，1.1要想在一个连接发送多个数据是串行的，会产生队首阻塞，多路复用会把文件切成小块轮流发送，在另一端重新组装，看起来像是并行传输，也会产生阻塞但是只阻塞了当前文件，其他文件不受影响，有一定的优化。阻塞是由于TCP的特性产生的，在TCP层面是无法解决的。

阻塞的主要原因是基于链路，两层链路TCP和TLS，加密以文件为单位，解密需要等完整的文件传输过来，所以会有当前文件的阻塞问题

HTTP3完全解决了阻塞

- 服务器主动推送，减少请求延迟

比websocket轻量，不能完全取代websocket，只是在推送方面取代，websocket是双向的，http是基于请求和响应，相当于一次请求多次响应

- 默认使用加密

**HTTP3**

解决了队首阻塞，发包时没有顺序，有一个编号，以包为单位，所有收到以后组装时发现有丢包要求重发，加解密也是以包为单位，不存在阻塞问题

基于QUIC，QUIC基于UDP，为了解决性能问题，同时也很严密，对数据包进行加密，不是链路加密

跨多层实现属于会话层和安全层

- 减少了握手的延迟，一次握手（首次通信，探查服务器在不在）或不握手（1TTR或0TTR），切换网络也不需要重新握手，因为没有链路
- 更灵活的多路复用，没有链路，没有阻塞
- 连接迁移，切换网络时连接不会断开，适用于移动端



3. 反向代理

正向代理，类似代购，反向代理，类似门房

nginx，c语言写的

用途：加密（配置HTTPS）和SSL加速，负载均衡（CDN），缓存静态文件，压缩，减速上传（有选择的丢包，延迟响应），安全，相当于一层堡垒给解决争取时间，外网发布（整合各种服务到同一个端口）



3. TLS握手

主要是协商加密算法，交换证书，交换密钥，切换到加密

TCP握手

客户端发送支持的协议版本，加密算法和压缩方法

服务端确定协议版本，加密算法和压缩方法，返回给客户端

服务端发送证书

服务端通知协商结束

客户端通过服务端公钥加密公钥和密钥种子发送给服务端

双方计算密钥

客户端通知切换加密

客户端准备完成

服务端通知切换加密

服务端准备完成

加密通信

通信完成后切断SSL

TCP挥手



3. TCP和UDP



2. HTTP缓存

分为强缓存和协商缓存，都是通过http header实现

强缓存优先于协商缓存

第一次请求没有缓存，服务器设置cache-control和expires或者etag和last-modified并返回资源

再次请求时，先检查强制缓存是否过期未过期不会发起请求直接从缓存中获取，状态为200

强缓存过期后进行协商缓存，依次发送文件上的etag/last-modified，头字段if-none-match/if-modified-since，服务器判断与自己维护的内容md5/时间戳是否相同，相同时使用浏览器缓存时返回304，否则说明资源变化返回最新数据状态200，然后重新进行缓存协商



3. TCP握手/挥手

**三次握手**

不包含数据

客户端发起连接请求，SYN指令，顺序号seq=x

服务端响应握手包发送SYN指令，顺序号seq=y，应答号ACK=x+1，客户端收到应答号，客户端能确认服务器能收到自己的数据，达到半连接，半连接不能保证服务器能收到客户端的数据

客户端发送应答号ACK=y+1，服务器收到应答号，服务端能确认客户端能收到自己的数据，达到全连接

三次交互保证对方可以正确得接收自己的数据

两次握手（半连接）的问题：如果客户端不断发起连接请求，服务端需要维护的连接数据越来越多，由于服务器还需要遍历数组，维护连接超时，数据过多时服务器会拒绝服务，这是拒绝服务攻击的一种，半连接攻击，缩短超时间可以缓解但是不能解决问题解决：防火墙，堆硬件

**四次挥手**

一般是客户端发起断开

收到断开请求后马上返回，然后做收尾工作，最后再发送断开请求，所以响应和FIN请求分成两次发送

客户端发送FIN指令，顺序号seq=x+2，应答号ACK=y+1

服务器立刻响应，应答号ACK=x+3

服务器做完收尾工作后发送FIN指令，顺序号seq=y+1

客户端收到后响应，应答号ACK=y+2，至此连接断开

## 渲染

1. 渲染原理

总体过程：

渲染部分通过html生成dom树，子资源加载，样式表计算，布局，绘制

主要参与模块：html解析器，css解析器，这两个在webcore中，js解释器（jscore或v8）

具体就是浏览器获取到html后，先进行字节流解码把字节数据转换为字符，包括一些字符的预处理，然后通过词法分析将字符串转化为标记同时生成dom树

遇到css时解析css，结构化css，不是树结构，是按照一定的数据结构生成css片段，在dom树上找到对应的节点，与css片段进行关联匹配，生成渲染树

如果遇到js，html解析器会暂停工作，将js给js解释器解析，js可以以桥接机制影响dom树和渲染树，js解析完成后html解析器继续工作

在渲染树的基础上加上布局规则一层一层得叠加生成布局渲染树，就是一个排版的过程

最后进行绘制，将数据显示到显示器上，需要调用显示后端，控件，字体，图形库视频解码库等，将视口里的内容映射到显示器上，就是计算像素点，通过显卡描到显示器上，一个图片就是一帧

以谷歌浏览器为例：

chrome是多进程浏览器，主进程就是浏览器进程，其他为子进程，比如插件进程，渲染由渲染进程负责，有多个一个域名是一个渲染进程，包括主线程和一些工作线程，js就跑在工作线程下，排版和栅格线程也在这个进程内运行

渲染过程：通过网络请求获取资源，html解析器开始解析根据html结构生成dom树，处理css片段生成数据结构，找到对应节点进行匹配关联生成渲染树，接下来进行排版就是计算每个节点的大小坐标和相对位置，基于根节点计算，生成排版树，然后进行一层一层合成生成层树，这些都在在主线程

一旦创建了层树确定了绘制顺序，就开始由GPU生成图，根据层树一个点一个点计算的，这里有一个优化，就是GPU把整个渲染任务进行分解，分成一个个小tile，通过GPU的各个核进行并行计算，计算完成之后将数据集中到显卡的显存里，显存将数据直接显示到显示器上，从屏幕左上角依次排列，速度很快具体取决于刷新率

# 性能优化

浏览器，传输过程